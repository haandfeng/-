# 归并排序 

我这里写的都是leetcode版
## 归并排序递归版
[[04 归并排序]]
[归并排序测试链接](https://leetcode.cn/problems/sort-an-array/submissions/533678048/)
主要还是注意变量是否越界等问题
```c++
void merge(vector<int>& nums, int l, int r){  
    int mid = (l + r)/2;  
    vector<int> help;  
    int pivot =mid+1;  
    int ini = l;  
    while (l<=mid && pivot<=r){  
        help.push_back(nums[l]<=nums[pivot]?nums[l++]:nums[pivot++]);  
    }  
    while(l<=mid){  
        help.push_back(nums[l++]);  
    }  
    while (pivot<=r){  
        help.push_back(nums[pivot++]);  
    }  
    for (int i : help) {  
        nums[ini++]=i;  
    }  
}  
void mergesort(vector<int>& nums, int l, int r){  
    if(l==r){return ;}  
    else{  
        int mid = (l+r)/2;  
        mergesort(nums,l,mid);  
        mergesort(nums,mid+1,r);  
        merge(nums,l,r);  
    }  
}  
vector<int> sortArray(vector<int>& nums) {  
    if(nums.size()>1)  
        mergesort(nums,0,nums.size()-1);  
    return nums;  
}
```
## 归并排序迭代版
改了merge的函数，加了变量m。不加的话m会被merge函数重新计算，那么边界条件就不对了

``` c++
//// 归并排序，填函数练习风格,迭代版  
  
void merge2(vector<int>& nums, int l,int mid, int r){  
    vector<int> help;  
    int pivot =mid+1;  
    int ini = l;  
    while (l<=mid && pivot<=r){  
        help.push_back(nums[l]<=nums[pivot]?nums[l++]:nums[pivot++]);  
    }  
    while(l<=mid){  
        help.push_back(nums[l++]);  
    }  
    while (pivot<=r){  
        help.push_back(nums[pivot++]);  
    }  
    for (int i : help) {  
        nums[ini++]=i;  
    }  
}  
  
  
void mergesort2(vector<int>& nums){  
    int n = nums.size()-1;  
    for (int l, m, r, step = 1; step <= n; step<<=1) {  
        l = 0;  
        while (l < n) {  
            m = l + step - 1;  
            // 越界了  
            if (m + 1 > n) {  
                break;  
            }  
            r = min(l + (step << 1) - 1, n);  
            merge2(nums, l, m, r);  
            l = r + 1;  
        }  
    }  
}


vector<int> sortArray(vector<int>& nums) {  
    if(nums.size()>1)  
        mergesort2(nums,0,nums.size()-1);  
    return nums;  
}  
  
```



# 归并分治
原理：
1）思考一个问题在大范围上的答案，是否等于，左部分的答案 + 右部分的答案 + 跨越左右产生的答案
2）计算“跨越左右产生的答案”时，如果加上左、右各自有序这个设定，会不会获得计算的便利性
3）如果以上两点都成立，那么该问题很可能被归并分治解决（话不说满，因为总有很毒的出题人）
4）求解答案的过程中只需要加入归并排序的过程即可，因为要让左、右各自有序，来获得计算的便利性

## 求数组小何

题目1: [[求数组小和]]  每个数右边有多少个数比他大  
[参考链接](https://www.nowcoder.com/practice/edfe05a1d45c4ea89101d936cac32469)
``` c++
// 求数组小和 测试链接 https://www.nowcoder.com/practice/edfe05a1d45c4ea89101d936cac32469
#include <iostream>  
#include <vector>  
using namespace std;  
//返回跨左右的累加和，也让他有序  
long mergeSum(int * arr,int l,int mid,int r){  
    vector<int> help;  
    long ret=0;  
    int rs=mid+1;  
    int ini=l;  
    for (int j = mid + 1, i = l, sum = 0; j <= r; j++) {  
        while (i <= mid && arr[i] <= arr[j]) {  
            sum += arr[i++];  
        }  
        ret += sum;  
    }  
    while (l<=mid && rs<=r){  
        help.push_back(arr[l]<=arr[rs]?arr[l++]:arr[rs++]);  
    }  
  
    while (l<=mid){  
        help.push_back(arr[l++]);  
    }  
    while (rs<=r){  
        help.push_back(arr[rs++]);  
    }  
    for(auto i :help){  
        arr[ini++]=i;  
    }  
    return ret;  
}  
  
long smallSum(int* arr, int l, int r){  
    if(l>=r){ return 0;}  
    int mid = (l+r)/2;  
    return smallSum(arr,l,mid)+smallSum(arr,mid+1,r)+mergeSum(arr,l,mid,r);  
  
}  
  
int main() {  
    int a;  
    while (cin>>a){  
        int * arr = new int [a];  
        if(a==0){  
            cout<<0<<endl;  
        }  
        for (int j = 0; j < a; ++j) {  
            cin>>arr[j];  
        }  
        cout<< smallSum(arr,0,a-1);  
        delete []arr;  
    }  
}
```
## 求数组中的逆序对
题目2: [[求数组中的逆序对数量]]  每个数右边有多少个数比他小  
[测试链接](https://leetcode.cn/problems/reverse-pairs/)
```c++
int mergeR(vector<int>& nums,int l, int m, int r){  
    vector<int> help;  
    int ret=0;  
    int a=l;  
    int b=m+1;  
    int count=0;  
    while (a<=m ){  
        while ((b<=r) && ((long long)nums[a]>(long long)2*(long long)nums[b])){  
            b++;  
            count++;  
        }  
        a++;  
        ret+=count;  
    }  
    b= m+1;  
    a= l;  
    while (l<=m && b<=r){  
        help.push_back(nums[l]<=nums[b]?nums[l++]:nums[b++]);  
    }  
    while (l<=m){  
        help.push_back(nums[l++]);  
    }  
    while (b<=r){  
        help.push_back(nums[b++]);  
    }  
  
    for(auto i :help){  
        nums[a++]=i;  
    }  
    return ret;  
}  
  
int reversePairsD(vector<int>& nums,int l, int r){  
    if (l==r){return 0;}  
    int mid = (l+r)/2;  
    return reversePairsD(nums,l,mid)+ reversePairsD(nums,mid+1,r)+mergeR(nums,l,mid,r);  
}  
  
int reversePairs(vector<int>& nums) {  
    if(nums.size()<=1){return 0;}  
    return reversePairsD(nums,0,nums.size()-1);  
}
```

# 随机快排
感觉这块的笔记比较乱，我就没管了，都复制上来，也有一些是和归并有关的
[[快速排序]]  
[[08 归并排序和快排]]   
[[03 归并排序与随机快排]]

主要思想就是找一个数，比他小的都在这个数左边，比他大的都在这个数右边
## 经典版
他这里没有随机一个数做比较，我随机了
[[快速排序#快速排序1.0]]
[测试链接](https://www.luogu.com.cn/problem/P1177) 在洛谷上测试会爆栈
自己写的时候有几个点没注意到：
1. 最后一定要把选定的pivot放回中间，这样才可以确保中间的左边都小于等于，中间的右边都大于
2. 注意边界条件，递归的时候，左边不应该包含中间，需要mid-1
```c++
#include <iostream>  
#include <vector>  
#include <ctime>  
#include <random>  
  
using namespace std;  
//// 测试链接 : https://www.luogu.com.cn/problem/P1177
void swap(long *arr,int l, int r){  
    long temp = arr[l];  
    arr[l] =arr[r];  
    arr[r]= temp;  
}  
int quickSwap(long *arr, long pivot,int l, int r){  
    int a = l;  
    int xi = a;  
    for (int i = l; i <= r; ++i) {  
        if(arr[i]<=pivot){  
            swap(arr,a,i);  
            if (arr[a]==pivot){  
                xi=a;  
            }  
            a++;  
        }  
    }  
    swap(arr,xi,a-1);  
    return  a-1;  
}  
  
void quickSort(long *arr, int l, int r){  
    if (l>=r){ return;}  
  
    std::default_random_engine e;  
    std::uniform_int_distribution<int> u(l,r); // 左闭右闭区间  
    e.seed(time(0));  
    long pivot =arr[u(e)];  
  
    int mid = quickSwap(arr,pivot,l,r);  
    quickSort(arr,l,mid-1);  
    quickSort(arr,mid+1,r);  
}  
  
int main() {  
    int a;  
    while (cin>>a){  
        long * arr = new long [a];  
        if(a==0){  
            continue;  
        }  
        for (int j = 0; j < a; ++j) {  
            cin>>arr[j];  
        }  
        quickSort(arr,0,a-1);  
        for (int j = 0; j < a; ++j) {  
            cout<<arr[j]<<" ";  
        }  
        cout<<endl;  
        delete []arr;  
    }  
}
```


## 荷兰版
[[快速排序#快速排序3.0]]
[测试链接]( https://www.luogu.com.cn/problem/P1177) 这次可以全对
荷兰国旗问题优化后的过程：
在当前范围上选择一个数字x，利用荷兰国旗问题进行数组的划分，<x =x >x
对<x范围重复这个过程，对>x范围重复这个过程

写的时候注意：边界条件 i<=last结束而不是i<=r，因为last右边的都被看完了
这道题分了三块区域，last 表示的右边区域的边界，mid表示的是左边区域的边界。难点就是怎么把他们用代码分区，建议看视频，有很好的讲解过程。我个人觉得有点像插入排序，标定好范围，然后遇到新的数，通过swap，把数据换到正确的空间
```c++
#include <iostream>  
#include <vector>  
#include <ctime>  
#include <random>  
  
using namespace std;  
//// 测试链接 : https://www.luogu.com.cn/problem/P1177
void swap(long *arr,int l, int r){  
    long temp = arr[l];  
    arr[l] =arr[r];  
    arr[r]= temp;  
}  
  
  
int quickSwap2(long *arr, long pivot,int l, int r,int &last){  
    int a = l;  
    last =r;  
    int i =l;  
//    last右边的数都已经被看过了，不需要看了  
    while (i<=last) {  
        if(arr[i]<pivot){  
            swap(arr,a,i);  
            i++;  
            a++;  
        }  
        else if(arr[i]==pivot){  
            i++;  
        }  
        // i不++，因为换过来的数还没看
        else{  
            swap(arr,i,last);  
            last--;  
        }  
  
    }  
    return  a-1;  
}  
  
void quickSort2(long *arr, int l, int r){  
    if (l>=r){ return;}  
  
    std::default_random_engine e;  
    std::uniform_int_distribution<int> u(l,r); // 左闭右闭区间  
    e.seed(time(0));  
    long pivot =arr[u(e)];  
    int last =0;  
//    last 表示的右边区域的边界，mid表示的是左边区域的边界  
    int mid = quickSwap2(arr,pivot,l,r,last);  
    quickSort2(arr,l,mid);  
    quickSort2(arr,last+1,r);  
}  
int main() {  
    int a;  
    while (cin>>a){  
        long * arr = new long [a];  
        if(a==0){  
            continue;  
        }  
        for (int j = 0; j < a; ++j) {  
            cin>>arr[j];  
        }  
        quickSort2(arr,0,a-1);  
        for (int j = 0; j < a; ++j) {  
            cout<<arr[j]<<" ";  
        }  
        cout<<endl;  
        delete []arr;  
    }  
}
```