# 一些类型题目收集的文档
[[链表相关问题]]
# 归并排序 

我这里写的都是leetcode版
## 归并排序递归版
[[04 归并排序]]
[归并排序测试链接](https://leetcode.cn/problems/sort-an-array/submissions/533678048/)
主要还是注意变量是否越界等问题
```c++
void merge(vector<int>& nums, int l, int r){  
    int mid = (l + r)/2;  
    vector<int> help;  
    int pivot =mid+1;  
    int ini = l;  
    while (l<=mid && pivot<=r){  
        help.push_back(nums[l]<=nums[pivot]?nums[l++]:nums[pivot++]);  
    }  
    while(l<=mid){  
        help.push_back(nums[l++]);  
    }  
    while (pivot<=r){  
        help.push_back(nums[pivot++]);  
    }  
    for (int i : help) {  
        nums[ini++]=i;  
    }  
}  
void mergesort(vector<int>& nums, int l, int r){  
    if(l==r){return ;}  
    else{  
        int mid = (l+r)/2;  
        mergesort(nums,l,mid);  
        mergesort(nums,mid+1,r);  
        merge(nums,l,r);  
    }  
}  
vector<int> sortArray(vector<int>& nums) {  
    if(nums.size()>1)  
        mergesort(nums,0,nums.size()-1);  
    return nums;  
}
```
## 归并排序迭代版
改了merge的函数，加了变量m。不加的话m会被merge函数重新计算，那么边界条件就不对了

``` c++
//// 归并排序，填函数练习风格,迭代版  
  
void merge2(vector<int>& nums, int l,int mid, int r){  
    vector<int> help;  
    int pivot =mid+1;  
    int ini = l;  
    while (l<=mid && pivot<=r){  
        help.push_back(nums[l]<=nums[pivot]?nums[l++]:nums[pivot++]);  
    }  
    while(l<=mid){  
        help.push_back(nums[l++]);  
    }  
    while (pivot<=r){  
        help.push_back(nums[pivot++]);  
    }  
    for (int i : help) {  
        nums[ini++]=i;  
    }  
}  
  
  
void mergesort2(vector<int>& nums){  
    int n = nums.size()-1;  
    for (int l, m, r, step = 1; step <= n; step<<=1) {  
        l = 0;  
        while (l < n) {  
            m = l + step - 1;  
            // 越界了  
            if (m + 1 > n) {  
                break;  
            }  
            r = min(l + (step << 1) - 1, n);  
            merge2(nums, l, m, r);  
            l = r + 1;  
        }  
    }  
}


vector<int> sortArray(vector<int>& nums) {  
    if(nums.size()>1)  
        mergesort2(nums,0,nums.size()-1);  
    return nums;  
}  
  
```



# 归并分治
原理：
1）思考一个问题在大范围上的答案，是否等于，左部分的答案 + 右部分的答案 + 跨越左右产生的答案
2）计算“跨越左右产生的答案”时，如果加上左、右各自有序这个设定，会不会获得计算的便利性
3）如果以上两点都成立，那么该问题很可能被归并分治解决（话不说满，因为总有很毒的出题人）
4）求解答案的过程中只需要加入归并排序的过程即可，因为要让左、右各自有序，来获得计算的便利性

## 求数组小何

题目1: [[求数组小和]]  每个数右边有多少个数比他大  
[参考链接](https://www.nowcoder.com/practice/edfe05a1d45c4ea89101d936cac32469)
``` c++
// 求数组小和 测试链接 https://www.nowcoder.com/practice/edfe05a1d45c4ea89101d936cac32469
#include <iostream>  
#include <vector>  
using namespace std;  
//返回跨左右的累加和，也让他有序  
long mergeSum(int * arr,int l,int mid,int r){  
    vector<int> help;  
    long ret=0;  
    int rs=mid+1;  
    int ini=l;  
    for (int j = mid + 1, i = l, sum = 0; j <= r; j++) {  
        while (i <= mid && arr[i] <= arr[j]) {  
            sum += arr[i++];  
        }  
        ret += sum;  
    }  
    while (l<=mid && rs<=r){  
        help.push_back(arr[l]<=arr[rs]?arr[l++]:arr[rs++]);  
    }  
  
    while (l<=mid){  
        help.push_back(arr[l++]);  
    }  
    while (rs<=r){  
        help.push_back(arr[rs++]);  
    }  
    for(auto i :help){  
        arr[ini++]=i;  
    }  
    return ret;  
}  
  
long smallSum(int* arr, int l, int r){  
    if(l>=r){ return 0;}  
    int mid = (l+r)/2;  
    return smallSum(arr,l,mid)+smallSum(arr,mid+1,r)+mergeSum(arr,l,mid,r);  
  
}  
  
int main() {  
    int a;  
    while (cin>>a){  
        int * arr = new int [a];  
        if(a==0){  
            cout<<0<<endl;  
        }  
        for (int j = 0; j < a; ++j) {  
            cin>>arr[j];  
        }  
        cout<< smallSum(arr,0,a-1);  
        delete []arr;  
    }  
}
```
## 求数组中的逆序对
题目2: [[求数组中的逆序对数量]]  每个数右边有多少个数比他小  
[测试链接](https://leetcode.cn/problems/reverse-pairs/)
```c++
int mergeR(vector<int>& nums,int l, int m, int r){  
    vector<int> help;  
    int ret=0;  
    int a=l;  
    int b=m+1;  
    int count=0;  
    while (a<=m ){  
        while ((b<=r) && ((long long)nums[a]>(long long)2*(long long)nums[b])){  
            b++;  
            count++;  
        }  
        a++;  
        ret+=count;  
    }  
    b= m+1;  
    a= l;  
    while (l<=m && b<=r){  
        help.push_back(nums[l]<=nums[b]?nums[l++]:nums[b++]);  
    }  
    while (l<=m){  
        help.push_back(nums[l++]);  
    }  
    while (b<=r){  
        help.push_back(nums[b++]);  
    }  
  
    for(auto i :help){  
        nums[a++]=i;  
    }  
    return ret;  
}  
  
int reversePairsD(vector<int>& nums,int l, int r){  
    if (l==r){return 0;}  
    int mid = (l+r)/2;  
    return reversePairsD(nums,l,mid)+ reversePairsD(nums,mid+1,r)+mergeR(nums,l,mid,r);  
}  
  
int reversePairs(vector<int>& nums) {  
    if(nums.size()<=1){return 0;}  
    return reversePairsD(nums,0,nums.size()-1);  
}
```

# 随机快排
感觉这块的笔记比较乱，我就没管了，都复制上来，也有一些是和归并有关的
[[快速排序]]  
[[08 归并排序和快排]]   
[[03 归并排序与随机快排]]

主要思想就是找一个数，比他小的都在这个数左边，比他大的都在这个数右边
## 经典版
他这里没有随机一个数做比较，我随机了
[[快速排序#快速排序1.0]]
[洛谷测试链接](https://www.luogu.com.cn/problem/P1177) 在洛谷上测试会爆栈
[leetcode测试链接](https://leetcode.cn/problems/sort-an-array/) 我没写这个的代码
自己写的时候有几个点没注意到：
1. 最后一定要把选定的pivot放回中间，这样才可以确保中间的左边都小于等于，中间的右边都大于
2. 注意边界条件，递归的时候，左边不应该包含中间，需要mid-1
```c++
#include <iostream>  
#include <vector>  
#include <ctime>  
#include <random>  
  
using namespace std;  
//// 测试链接 : https://www.luogu.com.cn/problem/P1177
void swap(long *arr,int l, int r){  
    long temp = arr[l];  
    arr[l] =arr[r];  
    arr[r]= temp;  
}  
int quickSwap(long *arr, long pivot,int l, int r){  
    int a = l;  
    int xi = a;  
    for (int i = l; i <= r; ++i) {  
        if(arr[i]<=pivot){  
            swap(arr,a,i);  
            if (arr[a]==pivot){  
                xi=a;  
            }  
            a++;  
        }  
    }  
    swap(arr,xi,a-1);  
    return  a-1;  
}  
  
void quickSort(long *arr, int l, int r){  
    if (l>=r){ return;}  
  
    std::default_random_engine e;  
    std::uniform_int_distribution<int> u(l,r); // 左闭右闭区间  
    e.seed(time(0));  
    long pivot =arr[u(e)];  
  
    int mid = quickSwap(arr,pivot,l,r);  
    quickSort(arr,l,mid-1);  
    quickSort(arr,mid+1,r);  
}  
  
int main() {  
    int a;  
    while (cin>>a){  
        long * arr = new long [a];  
        if(a==0){  
            continue;  
        }  
        for (int j = 0; j < a; ++j) {  
            cin>>arr[j];  
        }  
        quickSort(arr,0,a-1);  
        for (int j = 0; j < a; ++j) {  
            cout<<arr[j]<<" ";  
        }  
        cout<<endl;  
        delete []arr;  
    }  
}
```


## 荷兰版
[[快速排序#快速排序3.0]]
[测试链接]( https://www.luogu.com.cn/problem/P1177) 这次可以全对
荷兰国旗问题优化后的过程：
在当前范围上选择一个数字x，利用荷兰国旗问题进行数组的划分，<x =x >x
对<x范围重复这个过程，对>x范围重复这个过程

写的时候注意：边界条件 i<=last结束而不是i<=r，因为last右边的都被看完了
这道题分了三块区域，last 表示的右边区域的边界，mid表示的是左边区域的边界。难点就是怎么把他们用代码分区，建议看视频，有很好的讲解过程。我个人觉得有点像插入排序，标定好范围，然后遇到新的数，通过swap，把数据换到正确的空间
```c++
#include <iostream>  
#include <vector>  
#include <ctime>  
#include <random>  
  
using namespace std;  
//// 测试链接 : https://www.luogu.com.cn/problem/P1177
void swap(long *arr,int l, int r){  
    long temp = arr[l];  
    arr[l] =arr[r];  
    arr[r]= temp;  
}  
  
  
int quickSwap2(long *arr, long pivot,int l, int r,int &last){  
    int a = l;  
    last =r;  
    int i =l;  
//    last右边的数都已经被看过了，不需要看了  
    while (i<=last) {  
        if(arr[i]<pivot){  
            swap(arr,a,i);  
            i++;  
            a++;  
        }  
        else if(arr[i]==pivot){  
            i++;  
        }  
        // i不++，因为换过来的数还没看
        else{  
            swap(arr,i,last);  
            last--;  
        }  
  
    }  
    return  a-1;  
}  
  
void quickSort2(long *arr, int l, int r){  
    if (l>=r){ return;}  
  
    std::default_random_engine e;  
    std::uniform_int_distribution<int> u(l,r); // 左闭右闭区间  
    e.seed(time(0));  
    long pivot =arr[u(e)];  
    int last =0;  
//    last 表示的右边区域的边界，mid表示的是左边区域的边界  
    int mid = quickSwap2(arr,pivot,l,r,last);  
    quickSort2(arr,l,mid);  
    quickSort2(arr,last+1,r);  
}  
int main() {  
    int a;  
    while (cin>>a){  
        long * arr = new long [a];  
        if(a==0){  
            continue;  
        }  
        for (int j = 0; j < a; ++j) {  
            cin>>arr[j];  
        }  
        quickSort2(arr,0,a-1);  
        for (int j = 0; j < a; ++j) {  
            cout<<arr[j]<<" ";  
        }  
        cout<<endl;  
        delete []arr;  
    }  
}
```
## 无序数组中的第k大
[[改写快排的方法求无序数组中的第k小]]
[测试链接](https://leetcode.cn/problems/kth-largest-element-in-an-array/)
改写快排就好了，根据位置再迭代
注意
1. K是第二大，说明在数组的1位置，所以k要-1
2. `if(l == r){return nums[l];}`   而不是直接返回，因为如果读到了最后一个数，说明这最后一个数就是答案。会出现这个错误是因为没有递归分清楚基准条件

``` c++
void swapK(vector<int>& arr,int l, int r){  
    int temp = arr[l];  
    arr[l] =arr[r];  
    arr[r]= temp;  
}  
int findKSwap(vector<int>& nums, int pivot,int l, int r,int &last){  
    int a = l;  
    int i = l;  
    last =r;  
    while (i<=last){  
        if (nums[i]>pivot){  
            swapK(nums,a,i);  
            a++;  
            i++;  
        }  
        else if(nums[i]==pivot){  
            i++;  
        }  
        else{  
            swapK(nums,i,last);  
            last--;  
        }  
    }  
    return  a;  
}  
int findKLarge(vector<int>& nums, int k,int l, int r){  
    if(l == r){return nums[l];}  
    default_random_engine e;  
    uniform_int_distribution<int> u(l,r); // 左闭右闭区间  
    e.seed(time(0));  
    int pivot =nums[u(e)];  
//    int pivot= nums[(l+r)/2];  
    // mid 是first  last 是last 分别代表左边界和右边界  
    int last =0;  
    int mid = findKSwap(nums,pivot,l,r,last);  
    if(k>=mid && k<=last){  
        return nums[k];  
    }  
    else if(k<mid){  
        return findKLarge(nums,k,l,mid-1);  
    }  
    else if (k>last){  
        return findKLarge(nums,k,last+1,r);  
    }  
    return -1;  
}  
int findKthLargest(vector<int>& nums, int k) {  
    return findKLarge(nums,k-1,0,nums.size()-1);  
}
```


# 堆 / 优先队列
大概介绍，建议直接看视频，往年的笔记有点乱
 [[堆结构]]
[[04 比较器与堆]]
[[06 比较器、堆结构、堆排序]]
## 代码自带的堆结构
[[Java中的容器, 队列, 堆栈#堆]]  
[[Java中的常见数据结构#小根堆]]   
[[Java中的常见数据结构#大根堆]]

C++的堆的使用
[参考链接](https://blog.csdn.net/weixin_36888577/article/details/79937886)

代码结束 `priority_queue < int , vector< int >,greater< int > > q`
•	第一个参数 int：表示存储在优先队列中的元素类型是整数。
•	第二个参数 vector< int >：表示内部容器类型是 vector，用于存储数据。你可以使用其他容器，如 deque，只要该容器支持随机访问迭代器、front()、push_back() 和 pop_back() 操作。
•	第三个参数 greater< int >：这是一个函数对象或比较类，用于比较两个元素的大小。greater< int > 使得优先队列变成一个最小堆，即最小的元素在顶部。

## 手写堆
[[手写堆]]  
[[建堆的两种办法]]
怎么建堆写在了下面的堆排序代码里
``` c++
template<typename T>  
class myHeap{  
public:  
    myHeap(vector<T> nums){  
        this->nums =nums;  
    }  
    // i位置的数，变小了，又想维持大根堆结构  
    // 向下调整大根堆 hepify(向下看)  
    void hepify(int i){  
        int l = 2*i+1; // 左孩子  
        while (l<nums.size()){  
            int max = l + 1 < nums.size() && nums[l + 1] > nums[l] ? l + 1 : l;  
            max = nums[i] > nums[max] ? i: max;  
            if(nums[max] == nums[i]){break;}  
            swap(i,max);  
            i = max;  
            i = 2*i+1;  
        }  
    }  
//    向上看  
    void insert(int i){  
        // （0-1）/2 = 0  
        while (nums[i]>nums[(i-1)/2]){  
            swap(i,(i-1)/2);  
            i = (i-1)/2;  
        }  
    }  
  
    T peek(){  
        return nums[0];  
    }  
  
    void pop(){ // 相当于删除一个数，在课上老师是用size控制的  
        swap(0,nums.size()-1);  
        nums.pop_back();  
        hepify(0);  
        return;  
    }  
private:  
    vector<T> nums;  
    void swap(int i, int j) {  
        T tmp = nums[i];  
        nums[i] = nums[j];  
        nums[j] = tmp;  
    }  
};
```

## 堆排序
[[堆排序]]  
[leetcode测试链接](https://leetcode.cn/problems/sort-an-array/)
[洛谷测试链接]( https://www.luogu.com.cn/problem/P1177) 没写。
``` c++
////堆排序 测试链接： https://leetcode.cn/problems/sort-an-array/void swap(vector<int>& nums,int i, int j) {  
    int tmp = nums[i];  
    nums[i] = nums[j];  
    nums[j] = tmp;  
}  
void hepify(vector<int>& nums,int i){  
    int l = i * 2 + 1;  
    while (l < nums.size()) {  
        // 有左孩子，l  
        // 右孩子，l+1  
        // 评选，最强的孩子，是哪个下标的孩子 如果没有右孩子 左孩子就是最强下标  
        int best = l + 1 < nums.size() && nums[l + 1] < nums[l] ? l + 1 : l;  
        // 上面已经评选了最强的孩子，接下来，当前的数和最强的孩子之前，最强下标是谁  
        best = nums[best] < nums[i] ? best : i;  
        if (nums[best] == nums[i]) {  
            break;  
        }  
        swap(nums, best, i);  
        i = best;  
        l = i * 2 + 1;  
    }  
}  
void pop(vector<int>& nums){ // 相当于删除一个数，在课上老师是用size控制的  
    swap(nums,0,nums.size()-1);  
    nums.pop_back();  
    hepify(nums,0);  
}  
void heapInsert(vector<int>& nums, int i){  
    while (nums[i]<nums[(i-1)/2]){  
        swap(nums,i,(i-1)/2);  
        i = (i-1)/2;  
    }  
}  
// 从顶到底建立大根堆，O(n * logn)  
// 依次弹出堆内最大值并排好序，O(n * logn)  
// 整体时间复杂度O(n * logn)  
void heapSort1(vector<int>& nums) {  
    vector<int> cNums =nums;  
    for (int i = 0; i < cNums.size(); i++) {  
        heapInsert(cNums, i);  
    }  
    int i =0;  
    while (cNums.size() > 1) {  
        nums[i++] = cNums[0];  
        pop(cNums);  
    }  
    nums[i]=cNums[0];  
}  
  
// 从底到顶建立大根堆，O(n)  
// 依次弹出堆内最大值并排好序，O(n * logn)  
// 整体时间复杂度O(n * logn)  
 void heapSort2(vector<int>& nums) {  
    vector<int> cNums =nums;  
    for (int i = cNums.size() - 1; i >= 0; i--) {  
        hepify(cNums, i);  
    }  
    int i =0;  
    while (cNums.size() > 1 ) {  
        nums[i++] = cNums[0];  
        pop(cNums);  
    }  
    nums[i]=cNums[0];  
}  
  
vector<int> sortArray(vector<int>& nums) {  
    heapSort2(nums);  
    return nums;  
}
```
## 合并K个升序链表
[[合并K个升序链表]]
[leetcode测试链接](https://leetcode.cn/problems/vvXgSW/description/)
[牛客测试链接](https://www.nowcoder.com/practice/65cfde9e5b9b4cf2b6bafa5f3ef33fa6)
``` c++
// 定义一个仿函数，用于比较两个整数  
struct CustomCompare {  
    bool operator()(ListNode*lhs, ListNode* rhs) {  
        // 使priority_queue成为一个最小堆  
        return lhs->val > rhs->val;  
    }  
};  
ListNode* mergeKLists(vector<ListNode*>& lists) {  
    priority_queue<ListNode*, vector<ListNode*>, CustomCompare> pq;  
    for (auto list :lists) {  
        if (list!= nullptr)  
            pq.push(list);  
    }  
    if (pq.empty())  
        return nullptr;  
    ListNode * head = pq.top();  
    ListNode * temp = head;  
    pq.pop();  
    if (head->next!= nullptr)  
        pq.push(head->next);  
    while (!pq.empty()){  
        head->next=pq.top();  
        head =head->next;  
        pq.pop();  
        if (head->next!= nullptr)  
            pq.push(head->next);  
    }  
    return temp;
```
## 最大线段重合问题
[[最大线段重合问题]]
[牛客测试链接](https://www.nowcoder.com/practice/1ae8d0b6bb4e4bcdbf64ec491f63fc37) 
[leetcode测试链接](https://leetcode.cn/problems/meeting-rooms-ii/) 要vip
抄的是牛客的，自己对stl不熟悉，导致这个写的很麻烦
``` c++
#include <iostream>  
#include <queue>  
#include <cmath>  
#include <algorithm>  
using namespace std;  
struct Less  
{  
    bool operator()(const pair<int, int>& kv1, const pair<int, int>& kv2)  
    {  
        return kv1.first < kv2.first;  
    }  
};  
template<class T>  
class Greater  
{  
public:  
    bool operator()(const T& a, const T& b)  
    {  
        return a > b;  
    }  
};  
int main()  
{  
    //接受数据  
    int N = 0;  
    scanf("%d", &N);  
  
    vector<pair<int, int>>v;//数据类型是键值对  
    int i = 0;  
    while (i < N)  
    {  
        int first = 0;  
        int second = 0;  
  
        scanf("%d %d", &first, &second);  
        if (first > second) std::swap(first, second);  
        v.push_back(make_pair(first, second));  
        ++i;  
    }  
//    v.push_back(make_pair(2, 3));  
//    v.push_back(make_pair(4, 6));  
//    v.push_back(make_pair(7, 8));  
//    v.push_back(make_pair(9, 10));  
//    v.push_back(make_pair(2, 3));  
//    v.push_back(make_pair(5, 7));  
//    v.push_back(make_pair(6, 10));  
//    v.push_back(make_pair(3, 8));  
  
    sort(v.begin(), v.end(), Less());  
    int MAX = 0;  
    priority_queue<int, vector<int>, Greater<int>> pq;  
    for (auto e : v)  
    {  
        //删除  
        while ((!pq.empty()) &&  
               (pq.top() <= e.first))  
        {  
            pq.pop();  
        }  
        //求重合线段  
        pq.push(e.second);  
        MAX = pq.size() > MAX ? pq.size() : MAX;  
    }  
    cout << MAX << endl;  
  
    return 0;  
}
```

## 数组和减半

[测试链接](https://leetcode.cn/problems/minimum-operations-to-halve-array-sum/)
[[数组和减半]]
最少操作次数，把一个数组的和减半，贪心算法，利用堆实现
要把原来的代码改成最大堆，忘记改了。还有需要进行浮点数的转换。我不熟练，建议还是看leetcode官方。
浮点数可以直接== 吗我有疑问，但是我直接 == 还是可以通过测试，我没在乎了，以后做题可能需要注意这个问题。
``` c++
void swap2(vector<double>& nums,int i, int j) {  
    double tmp = nums[i];  
    nums[i] = nums[j];  
    nums[j] = tmp;  
}  
void heapify2(vector<double>& nums,int i){  
    int l = i * 2 + 1;  
    while (l < nums.size()) {  
        // 有左孩子，l  
        // 右孩子，l+1  
        // 评选，最强的孩子，是哪个下标的孩子 如果没有右孩子 左孩子就是最强下标  
        int best = l + 1 < nums.size() && nums[l + 1] > nums[l] ? l + 1 : l;  
        // 上面已经评选了最强的孩子，接下来，当前的数和最强的孩子之前，最强下标是谁  
        best = nums[best] > nums[i] ? best : i;  
        if (nums[best]==nums[i]) {  
            break;  
        }  
        swap2(nums, best, i);  
        i = best;  
        l = i * 2 + 1;  
    }  
}  
void pop2(vector<double>& nums){ // 相当于删除一个数，在课上老师是用size控制的  
    swap2(nums,0,nums.size()-1);  
    nums.pop_back();  
    heapify2(nums,0);  
}  
void heapSort(vector<double>& nums) {  
    vector<double> cNums =nums;  
    for (int i = cNums.size() - 1; i >= 0; i--) {  
        heapify2(cNums, i);  
    }  
    int i =0;  
    while (cNums.size() > 1 ) {  
        nums[i++] = cNums[0];  
        pop2(cNums);  
    }  
    nums[i]=cNums[0];  
}  
int halveArray(vector<int>& nums) {  
    vector<double> numsD (nums.begin(),nums.end());  
    heapSort(numsD);  
    double sum =0;  
    for(int num:numsD){  
        sum+=num;  
    }  
    sum = sum/2.0;  
    double half=0;  
    int count =0;  
    while (half<sum){  
        half+=numsD[0]/2.0;  
        numsD[0] =numsD[0]/2.0;  
        heapify2(numsD,0);  
        count++;  
    }  
    return count;  
  
}
```
# 基数排序
 [[基数排序代码]]  
 [[基数排序的没有桶的优化版本-难点解释]]

 [测试链接]( https://leetcode.cn/problems/sort-an-array/)
 思路：按照位数不断对代码排序，从个位数，十位数等等开始排序，依次排好序之后整体就有序了
  但写起来还是挺麻烦的，注意前缀和，求位数，处理非负数的问题
  我改变了数据类型，注意数组初始化等操作，卡这了和做不一样
``` c++
  int bit(long max){  
    int ans = 0;  
    while (max > 0) {  
        ans++;  
        max /= 10;  
    }  
    return ans;  
}  
void RadixSort(vector<long>& nums,int bits){  
//    每一位开始排序  
  
    long * help = new long[nums.size()];  
    for (int offset = 1; bits > 0; offset *= 10, bits--) {  
        // 每一位各有多少个数字  
        int cnts[10]={};  
        for (int i = 0; i < nums.size(); i++) {  
            // 数字提取某一位的技巧  
            cnts[(nums[i] / offset) % 10]++;  
        }  
        // 处理成前缀次数累加的形式  
        for (int i = 1; i < 10; i++) {  
            cnts[i] = cnts[i] + cnts[i - 1];  
        }  
        // 注意从后面到前面，这样才可以利用前缀和，因为前缀和是所有某个值的数的和，指向了最后面（保持稳定性）  
        for (int i = nums.size() - 1; i >= 0; i--) {  
            // 前缀数量分区的技巧  
            // 第i个数，在  
            help[--cnts[(nums[i] / offset) % 10]] = nums[i];  
        }  
        for (int i = 0; i < nums.size(); i++) {  
            nums[i] = help[i];  
        }  
    }  
    delete[] help;  
}  
vector<int> sortArray(vector<int>& nums) {  
    vector<long>num(nums.begin(),nums.end());  
    if(nums.size()>1){  
        int min =0;  
        long max =0;  
        for (int i = 0; i < nums.size(); ++i) {  
            min = min <nums[i] ? min:nums[i];  
        }  
        for (int i = 0; i < nums.size(); ++i) {  
            num[i] -= min;  
            max = max >num[i] ? max:num[i];  
        }  
        RadixSort(num,bit(max));  
        for (int i = 0; i < nums.size(); i++) {  
            num[i] += min;  
            nums[i] =num[i];  
        }  
    }  
    return nums;  
}
```
# 排序总结
看这里吧，懒得写
[[05 trie、桶排序、排序总结]]

# 位运算
## 异或
### 如何不用额外变量交换两个数
 [[如何不用额外变量交换两个数]]  
 本质是 a^a =0  a^0=a
 ```c++
 void swap(int a, int b) {  
    a = a ^ b;  
    b = a ^ b;  
    a = a ^ b;  
}
```

### 返回两个数的最大值
[[不用任何判断语句和比较操作，返回两个数的最大值]]
感觉挺弱智挺麻烦的，要确保a和b乘一个互斥的0/1的数。首先使用a-b获得一个整数，然后判断符号，利用符号让a和b乘的数是互斥的。
```c++
int flip(int n) {  
    return n ^ 1;  
}  
  
// 非负数返回1  
// 负数返回0  
int sign(int n) {  
    return flip((unsigned)n >> 31);  
}  
int getMax(int a, int b) {  
    // write code here  
    // c可能是溢出的  
    int c = a - b;  
    // a的符号  
    int sa = sign(a);  
    // b的符号  
    int sb = sign(b);  
    // c的符号  
    int sc = sign(c);  
    // 判断A和B，符号是不是不一样，如果不一样diffAB=1，如果一样diffAB=0  
    int diffAB = sa ^ sb;  
    // 判断A和B，符号是不是一样，如果一样sameAB=1，如果不一样sameAB=0  
    int sameAB = flip(diffAB);  
    int returnA = diffAB * sa + sameAB * sc;  
    int returnB = flip(returnA);  
    return a * returnA + b * returnB;  
}
}
```
### 找到缺失的数
[[缺失数字]]
给定一个包含 `[0, n]` 中 `n` 个数的数组 `nums` ，找出 `[0, n]` 这个范围内没有出现在数组中的那个数
[测试链接](https://leetcode.cn/problems/missing-number/int)
本质还是上面的两个性质，扩展多n个的话就是 x = a^b^c  y=a^b  c=x^y
```c++
// 找到缺失的数字  
// 测试链接 : https://leetcode.cn/problems/missing-number/int missingNumber(vector<int>& nums) {  
    int all=0;  
    for (int i = 0; i < nums.size(); ++i) {  
        all^=i;  
        all^=nums[i];  
    }  
    all^=nums.size();  
    return all;  
}
```
### 提取整形数最右侧的1
[[提取整形数最右侧的1]]  
Brian Kernighan算法
自己本身和自己取反+1的数（自己的相反数）相与就可以得到最右边的数
``` c++
int rightOne = eor1 & (-eor1);
```
### 一个数组中出现了奇数次的数
 [[一个数组中出现了奇数次的数]]   原理和找到缺失的数一样
 [测试链接](https://leetcode.cn/problems/single-number/ )
 ``` c++
// 数组中1种数出现了奇数次，其他的数都出现了偶数次  
// 返回出现了奇数次的数  
// 测试链接 : https://leetcode.cn/problems/single-number/  
  
int singleNumber(vector<int>& nums) {  
    int a=0;  
    for (auto i: nums) {  
        a^=i;  
    }  
    return a;  
}
```
### 一个数组中出现奇数次的两个数  
[[一个数组中出现奇数次的两个数]]  
两个数一定不一样。所以所有数全部相与了之后，得到的数最右边的1，一定就是第一位这两个数不同的地方。
通过这个最右边不一样的1就可以分开两个数。两个数在那一位，一个=1，一个=0。 与得到的最右侧的1相与，其中一个数一定等于0，这样就可以分隔出他们了
去反的时候要转换一下long，不然会溢出
[测试链接](https://leetcode.cn/problems/single-number-iii/)
``` c++
// 数组中有2种数出现了奇数次，其他的数都出现了偶数次  
// 返回这2种出现了奇数次的数  
// 测试链接 : https://leetcode.cn/problems/single-number-iii/  
vector<int> singleNumber2(vector<int>& nums) {  
    vector<int> ret;  
    int a=0;  
    for (auto i: nums) {  
        a^=i;  
    }  
    int rightOne= a & (-(long)a);  
    int b =0;  
    for (auto i: nums) {  
        if((i & rightOne)==0){  
            b^=i;  
        }  
    }  
    ret.push_back(b);  
    ret.push_back(a^b);  
    return ret;  
}
```
### 一个数组中有一种数出现K次，其他数都出现了M次
这道题其实和==异或==没关系只是刚好放一起了
[[一个数组中有一种数出现K次，其他数都出现了M次]]
更通用的方法  
	已知数组中只有1种数出现次数少于m次，其他数都出现了m次  
	返回出现次数小于m次的那种数
测试题目只是通用方法的一个特例，课上讲了更通用的情况。这道题把每一位的数都提取出来，存到数组里。然后再计算
[测试链接](https://leetcode.cn/problems/single-number-ii/)
``` c++
int singleNumber3(vector<int>& nums) {  
    int ans=0;  
    int cnt[32];  
    for (int i = 0; i < 32; ++i) {  
  
        for(auto num: nums){  
            cnt[i]+= (num>>i) & 1;  
        }  
    }  
    for (int i = 0; i < 32; ++i) {  
        ////这里的3是特殊情况，正常情况3要换成m  
        if( cnt[i] % 3!=0 ){  
            ans |= 1 << i;  
        }  
    }  
    return ans;  
}
```
## 位运算操作
### 判断一个整数是不是2的幂
[[判断一个整数是不是2的幂]]
[测试链接]( https://leetcode.cn/problems/power-of-two/)
注意要判断是否大于0，0不是n的n次幂，并且防止越界
```c++
// Brian Kernighan算法  
// 提取出二进制里最右侧的1（有且仅有一个1）  
// 判断一个整数是不是2的幂  
// 测试链接 : https://leetcode.cn/problems/power-of-two/
bool isPowerOfTwo(int n) {  
    return n > 0 && n== (n & (-n));  
}
```
### 判断一个整数是不是3的幂
[[判断一个整数是不是3的幂]]
[测试链接](https://leetcode.cn/problems/power-of-three/)
```c++
    // 如果一个数字是3的某次幂，那么这个数一定只含有3这个质数因子  
    // 1162261467是int型范围内，最大的3的幂，它是3的19次方  
    // 这个1162261467只含有3这个质数因子，如果n也是只含有3这个质数因子，那么  
    // 1162261467 % n == 0  
    // 反之如果1162261467 % n != 0 说明n一定含有其他因子  
bool isPowerOfThree(int n) {  
    return n > 0 && 1162261467 % n == 0;  
}
```
### 返回大于等于n的最小的2的幂
[[返回大于等于n的最小的2的幂]]
c++无符号右移，要先正常无符号整型(unsigned)
``` c++
 int near2power(int n) {  
   if (n <= 0) {  
      return 1;  
   }  
   n--;  
   n |= (unsigned)n >> 1;  
   n |= (unsigned)n >> 2;  
   n |= (unsigned)n >> 4;  
   n |= (unsigned)n >> 8;  
   n |= (unsigned)n >> 16;  
   return n + 1;  
}

```
### 区间[left, right]内所有数字 & 的结果
[[区间[left, right]内所有数字 & 的结果]]
[测试链接](https://leetcode.cn/problems/bitwise-and-of-numbers-range/)
``` c++
int rangeBitwiseAnd(int left, int right) {  
    while (left < right) {  
        right -= right & -right;  
    }  
    return right;  
}
```
### 反转一个二进制的状态
[[反转一个二进制的状态]]
[测试链接](https://leetcode.cn/problems/reverse-bits/) 
需要导包 
``` c++
#include <cstdint>
uint32_t reverseBits(uint32_t n) {  
    n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);  
    n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);  
    n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);  
    n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);  
    n = (n >> 16) | (n << 16);  
    return n;  
}
```
### 返回一个数二进制中有几个1
[[返回一个数二进制中有几个1]]
[测试链接](https://leetcode.cn/problems/hamming-distance/)
```c++
// 返回n的二进制中有几个1  
// 两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。  
// 给你两个整数 x 和 y，计算并返回它们之间的汉明距离  
// 测试链接 : https://leetcode.cn/problems/hamming-distance/int countOne(int n){  
    n = (n & 0x55555555) + (((unsigned)n >> 1) & 0x55555555);  
    n = (n & 0x33333333) + (((unsigned)n >> 2) & 0x33333333);  
    n = (n & 0x0f0f0f0f) + (((unsigned)n >> 4) & 0x0f0f0f0f);  
    n = (n & 0x00ff00ff) + (((unsigned)n >> 8) & 0x00ff00ff);  
    n = (n & 0x0000ffff) + ((unsigned)(n >> 16) & 0x0000ffff);  
    return n;  
}  
int hammingDistance(int x, int y) {  
    return countOne(x^y);  
}
```
## 位图
[[Java中位图的实现]]  
[[位图]]
``` c++
class  bitmap{  
    bitmap(int n){  
        // a/b如果结果想向上取整，可以写成 : (a+b-1)/b        // 前提是a和b都是非负数  
        this->set = new int [(n+31)/32];  
    }  
    void add(int num){  
        set[num/32] |= 1<<(num % 32);  
    }  
    void remove(int num){  
        set[num/32] &= ~(1<<(num % 32));  
    }  
    void reverse(int num){  
        set[num/32] ^= (1<<(num % 32));  
    }  
    bool contain(int num){  
        return (((set[num/32]>>(num % 32)) & 1) ==1);  
    }  
    int *set;  
};
```

### 设计位集
[[2166.设计位集]]
[测试链接](https://leetcode-cn.com/problems/design-bitset/)
小抄一下，自己写的没有注意到时间复杂度的问题。
还有一个问题，注意数组多用vector吧，不要new了，new出来在leetcode不为0
```c++
class Bitset {  
private:  
    vector<int> arr;   // 存储每一位的数组  
    int cnt = 0;   // 1 的个数  
    int reversed = 0;   // 反转操作的次数奇偶性  
public:  
    Bitset(int size) {  
        arr.resize(size);  
        cnt = 0;  
        reversed = 0;  
    }  
  
    void fix(int idx) {  
        //  1 1 or 0 0 一样的时候表明那个bit没被设置，设置bit  
        if ((arr[idx] ^ reversed) == 0) {  
            arr[idx] ^= 1;  
            ++cnt;  
        }  
    }  
  
    void unfix(int idx) {  
        if ((arr[idx] ^ reversed) == 1) {  
            arr[idx] ^= 1;  
            --cnt;  
        }  
    }  
  
    void flip() {  
        reversed ^= 1;  
        cnt = arr.size() - cnt;  
    }  
  
    bool all() {  
        return cnt == arr.size();  
    }  
  
    bool one() {  
        return cnt > 0;  
    }  
  
    int count() {  
        return cnt;  
    }  
  
    string toString() {  
        string res;  
        for (int bit: arr) {  
            res.push_back('0' + (bit ^ reversed));  
        }  
        return res;  
    }  
};
```
## 位运算实现加减乘除
[[用位运算实现加减乘除]]
[测试链接]( https://leetcode.cn/problems/divide-two-integers/)
divide是算了边界条件版
```c++
//// 位运算实现加减乘除  
// 不用任何算术运算，只用位运算实现加减乘除  
// 代码实现中你找不到任何一个算术运算符  
// 测试链接 : https://leetcode.cn/problems/divide-two-integers/
int add(int a, int b){  
    int ans = a;  
    while (b != 0){  
        // 无进位相加  
        ans  = a ^ b;  
        // 进位信息, 需要一个a来保存没有异或前的数  
        b = (a & b) << 1;  
        a = ans;  
    }  
    return  ans;  
}  
int neg(int a){  
    return  add((~a),1);  
}  
int myMinus(int a, int b){  
    return add(a,neg(b));  
}  
int multiple(int a, int b){  
    int ans = 0;  
    while(b != 0){  
        // 最右边是1  
        if(( b & 1 )!=0){  
            ans  = add (ans,a);  
        }  
//        a 左移一位(乘法)  
        a<<=1;  
        // b无符号右移动  
        (unsigned )b>>1;  
    }  
    return ans;  
}  
int myDiv(int a, int b){  
    // 先把所有数转成非负数，但要注意这个负数，不能是整数最小值  
    int x = a < 0 ? neg(a) : a;  
    int y = b < 0 ? neg(b) : b;  
    int ans = 0;  
    for (int i = 30; i >=0; i= myMinus(i,1)) {  
        //    为了防止溢出风险，选择被除数向右移动，而不是除数向左移动  
        if ((x >> i) >= y) {  
            ans |= (1 << i);  
//            这里不会溢出了，因为(x >> i) >= y  
            x = myMinus(x, y << i);  
        }  
    }  
    // 异号  
    return a < 0 ^ b < 0 ? neg(ans) : ans;  
}  
  
int divide(int dividend, int divisor) {  
//    int max = (1<<31)-1;//这里要加括号，运算符优先级  
    int min = 1<<31;//由于int是32位的  
    int max = neg(min+1);  
//    a 和 b 都可能是整数最小值的讨论  
    if(dividend== min && divisor== min){  
        return 1;  
    }  
    if (dividend != min && divisor != min) {  
        // a和b都不是整数最小，那么正常去除  
        return myDiv(dividend, divisor);  
    }  
    if (divisor == min) {  
        // a不是整数最小，b是整数最小  
        return 0;  
    }  
    // a是整数最小，b是-1，返回整数最大，因为题目里明确这么说了  
    if (divisor == neg(1)) {  
        return max;  
    }  
    // a是整数最小，b不是整数最小，b也不是-1  
    // 防止越界 变成 （a+b）/b  最后加回1  
    dividend = add(dividend, divisor > 0 ? divisor : neg(divisor));  
    int ans = myDiv(dividend, divisor);  
    int offset = divisor > 0 ? neg(1) : 1;  
    return add(ans, offset);  
}
```
# 链表高频题和必备技巧
我这里主要关注的是非容器的做法
## 返回两个无环链表相交的第一个节点
[[两个无环链表返回第一个相交节点]]
[测试链接](https://leetcode.cn/problems/intersection-of-two-linked-lists/)
主要就是找两个节点长度的差异，这样就可以对两个链表对齐，对齐之后一起走就可以找到相同的点。
```c++
ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {  
    int diff= 0;  
    if (headA== nullptr||headB== nullptr){  
        return nullptr;  
    }  
    ListNode * a = headA;  
    ListNode * b = headB;  
    while (headA->next!= nullptr){  
        headA =headA->next;  
        diff++;  
    }  
    while (headB->next!= nullptr){  
        headB = headB->next;  
        diff--;  
    }  
    if (diff>=0){  
        for (int i = 0; i < diff; ++i) {  
            a = a->next;  
        }  
        while (a!=b){  
            a =a->next;  
            b= b->next;  
        }  
        return  a;  
    } else{  
        for (int i = 0; i < -diff; ++i) {  
            b = b->next;  
        }  
        while (a!=b){  
            a =a->next;  
            b= b->next;  
        }  
        return  b;  
    }  
}
```
## 每k个节点一组翻转链表
[[K个节点的组内逆序调整]]
[测试链接](https://leetcode.cn/problems/reverse-nodes-in-k-group/)
扣了一天，具体看解释吧，感觉很难
```c++
// 每k个节点一组翻转链表  
// 测试链接：https://leetcode.cn/problems/reverse-nodes-in-k-group/  
  
ListNode* reverse(ListNode* head, ListNode* end){  
    ListNode * pre = nullptr;  
    ListNode * next = nullptr;  
    ListNode * cur = head;  
    end = end->next;  
    while (head != end){  
        next = head->next;  
        head->next = pre;  
        pre = head;  
        head = next;  
    }  
//    最开始的头，等于反转后的尾，指向下一个的头  
    cur->next =end;  
//    返回头  
    return pre;  
}  
ListNode* getEnd(ListNode* s, int k){  
    while (--k != 0 && s != nullptr) {  
        s = s->next;  
    }  
    return s;  
}  
ListNode* reverseKGroup(ListNode* head, int k) {  
    ListNode * start = head;  
    ListNode * end = getEnd(start, k);  
    if (end == nullptr) {  
        return head;  
    }  
    // 第一组很特殊因为牵扯到换头的问题  
    head = end;  
//    start变尾 end变头  
    reverse(start, end);  
    // 翻转之后start变成了上一组的结尾节点  
    ListNode *lastTeamEnd = start;  
    while (lastTeamEnd->next != nullptr) {  
        start = lastTeamEnd->next;  
        end = getEnd(start, k);  
        if (end == nullptr) {  
            return head;  
        }  
        //    start变尾 end变头  
        reverse(start, end);  
//        上一个的尾巴，指向反转后的头（end）  
        lastTeamEnd->next = end;  
//        更新尾巴变成下一个尾巴  
        lastTeamEnd = start;  
    }  
    return head;  
}
```
## 复制带随机指针的链表
[[复制带随机指针的链表]]
[测试链接](https://leetcode-cn.com/problems/copy-list-with-random-pointer)
主要思路就是往每一个节点处都插入一个复制节点，这样就可以方便跳转复制了。注意拆链的时候要在最后拆，不然原先结构就错了
```c++
Node* copyRandomList(Node* head) {  
    if (head == nullptr) { return head; }  
    Node *temp = head;  
    // 先插入  
    while (temp != nullptr) {  
        Node * next = temp->next;  
        temp->next = new Node(temp->val);  
        temp->next->next = next;  
        temp = next;  
    }  
    // 重新遍历，开始拷贝  
    temp = head;  
    Node* newHead = temp->next;  
    while (temp != nullptr) {  
        Node* copyNode = temp->next;  
//        拷贝  
        if(temp->random!= nullptr){  
            copyNode->random = temp->random->next;  
        } else{  
            copyNode->random= nullptr;  
        }  
        temp = temp->next->next;  
    }  
    temp =head;  
    while (temp!= nullptr){  
        Node * next = temp->next->next;  
        Node* copyNode = temp->next;  
        copyNode->next = next != nullptr ? next->next : nullptr;  
        temp->next = next;  
        temp = next;  
    }  
    return newHead;  
}
```
## 判断链表是否是回文结构
[[判断链表是否为回文结构]]
[测试链接](https://leetcode.cn/problems/palindrome-linked-list/description/)
用快慢指针求终点，然后反转，在判断
``` c++
// 判断链表是否是回文结构  
// 测试链接 : https://leetcode.cn/problems/palindrome-linked-list/bool isPalindrome(ListNode* head) {  
    if (head== nullptr || head->next == nullptr){return true;}  
    ListNode* slow = head;  
    ListNode* fast = head;  
//    When end slow is the middle point  
    while (fast->next != nullptr && fast->next->next != nullptr){  
        slow = slow->next;  
        fast= fast->next->next;  
    }  
//  reverse nodes after middle  
    ListNode* pre = nullptr;  
    ListNode* next = nullptr;  
    ListNode* mr = slow->next;  
    while (mr!= nullptr){  
        next = mr->next;  
        mr->next = pre;  
        pre = mr;  
        mr = next;  
    }  
    bool ans = true;  
    ListNode* right = pre;  
    ListNode* left = head;  
    while (right!= nullptr){  
        if (left->val!=right->val){  
            ans = false;  
            break;  
        }  
        left = left->next;  
        right =right->next;  
    }  
    ListNode* cur = pre;  
    pre = nullptr;  
    while (cur!= nullptr){  
        next = cur->next;  
        cur->next = pre;  
        pre = cur;  
        cur = next;  
    }  
    return ans;  
}
```
## 返回链表的第一个入环节点
[[找到链表第一个入环节点]]  
[测试链接](https://leetcode.cn/problems/linked-list-cycle-ii/)
特殊公式: 相遇之后，快指针返回头，各自一起走一步，就会相遇的时候就是入环节点
```c++
ListNode *detectCycle(ListNode *head) {  
    if (head == nullptr || head->next == nullptr || head->next->next == nullptr) {  
        return nullptr;  
    }  
    ListNode* slow = head->next;  
    ListNode* fast = head->next->next;  
    while (slow != fast) {  
        if (fast->next == nullptr || fast->next->next == nullptr) {  
            return nullptr;  
        }  
        slow = slow->next;  
        fast = fast->next->next;  
    }  
    fast = head;  
    while (slow != fast) {  
        slow = slow->next;  
        fast = fast->next;  
    }  
    return slow;  
}
```
## 在链表上排序
[[在链表上排序]]
[测试链接](https://leetcode.cn/problems/sort-list/)
很难，虽然逻辑上很简单，担忧很多coding的细节和需要考虑的地方。再练
```c++
ListNode *start;  
ListNode *end;  
ListNode* findEnd(ListNode* s, int k){  
    while (s->next!= nullptr && --k !=0){  
        s = s->next;  
    }  
    return s;  
}  
  
  
// l1...r1 -> null : 有序的左部分  
// l2...r2 -> null : 有序的右部分  
// 整体merge在一起，保证有序  
// 并且把全局变量start设置为整体的头，全局变量end设置为整体的尾  
void mergeList (ListNode* l1 , ListNode* r1,ListNode* l2 , ListNode* r2){  
    // 需要一个pre变量，这样遇到谁小的问题的时候才可以串list，  
    // start 用来确认整个链表的头  
    ListNode *pre;  
    // 先判断用谁做头  
    if (l1->val <= l2->val) {  
        start = l1;  
        pre = l1;  
        l1 = l1->next;  
    } else {  
        start = l2;  
        pre = l2;  
        l2 = l2->next;  
    }  
    while (l1!= nullptr && l2 != nullptr){  
        if(l1->val<=l2->val){  
            pre->next = l1;  
            l1 = l1->next;  
            pre = pre->next;  
        } else{  
            pre->next = l2;  
            l2 = l2->next;  
            pre = pre->next;  
        }  
    }  
    if (l1 == nullptr){  
        // 连起来  
        pre->next = l2;  
        end = r2;  
    } else{  
        pre->next = l1;  
        end = r1;  
    }  
}  
// 时间复杂度O(n*logn)，额外空间复杂度O(1)，有稳定性  
// 注意为了额外空间复杂度O(1)，所以不能使用递归  
// 因为mergeSort递归需要O(log n)的额外空间  
ListNode* sortList(ListNode* head) {  
    ListNode* cur = head;  
    int n = 0;  
    while (cur!= nullptr){  
        ++n;  
        cur = cur->next;  
    }  
    cur = head;  
    ListNode *l1, *r1, *l2, *r2, *next, *lastTeamEnd;  
    for (int i = 1; i < n; i<<=1) {  
        // 第一组很特殊，因为要决定整个链表的头，所以单独处理  
        l1 = head;  
        l1 = head;  
        r1 = findEnd(l1, i);  
        l2 = r1->next;  
        r2 = findEnd(l2, i);  
        next = r2->next;  
//        全部置空，断开两个list方便合并  
        r1->next = nullptr;  
        r2->next = nullptr;  
        mergeList(l1,r1,l2,r2);  
        // 更新后的头  
        head = start;  
        lastTeamEnd = end;  
        while (next != nullptr) {  
            l1 = next;  
            r1 = findEnd(l1, i);  
            l2 = r1->next;  
            if (l2 == nullptr) {  
                lastTeamEnd->next = l1;  
                break;  
            }  
            r2 = findEnd(l2, i);  
            next = r2->next;  
            r1->next = nullptr;  
            r2->next = nullptr;  
            mergeList(l1, r1, l2, r2);  
            lastTeamEnd->next = start;  
            lastTeamEnd = end;  
        }  
    }  
    return head;  
}
```
# 数据结构设计高频题
## setAll功能的哈希表
[[数据结构设计之O(1)实现setAll]]
设置全局变量，利用修改时间比较来获得值
小抄了一下牛客的答案懒了
``` c++
#include <iostream>
#include <unordered_map>
#include <utility>
using namespace std;

class MyMap 
{
    // pair <value, cnt> // 加时间戳技术
    std::unordered_map<int, std::pair<int, int>> umap;
    int setAllValue;
    int setAllTime{0};
    int cnt{1};
public:
    void put(int key, int value) 
    {
        umap[key] = {value, cnt++}; 
    }

    int get(int key) 
    {
        if (!containsKey(key)) {
            return -1;
        }

        if (umap[key].second < setAllTime) {
            return setAllValue;
        }
        return umap[key].first;
    }

    bool containsKey(int key)
    {
        if (umap.find(key) == umap.end()) {
            return false;
        }
        return true;
    }

    void setAll(int value)
    {
        setAllValue = value;
        setAllTime = cnt++;
    }

};

int main() {
    MyMap mymap;
    int n;
    std::cin >> n;
    int op;
    int key;
    int value;
    for (int i = 0; i < n; i++) {
        std::cin >> op;
        switch (op) {
            case 1:
                std::cin >> key >> value;
                mymap.put(key, value);
                break;
            case 2:
                std::cin >> key;
                std::cout << mymap.get(key) << std::endl;
                break;
            case 3:
                std::cin >> value;
                mymap.setAll(value);
                break;
        }

    }
}
// 64 位输出请用 printf("%lld")

```
## 实现LRU结构
[[LRU缓存机制]]  
[[LRU内存替换算法的实现]]
[测试链接](https://leetcode.cn/problems/lru-cache/)
双向队列实现lru
实现O(1)的时间复杂度，要自己手写双向链表，调用map接口。注意双向链表的增删查改的边界条件处理（动的那个点是头部点，尾部点，中间点）。特别是在c++的delete
``` c++
class doubleNode{  
public:  
    doubleNode(int key, int value){  
        this->next= nullptr;  
        this->pre= nullptr;  
        this->val = value;  
        this->key = key;  
    }  
    int val;  
    int key;  
    doubleNode* next;  
    doubleNode* pre;  
};  
class doubleList{  
public:  
    doubleNode* head;  
    doubleNode* tail;  
    int size;  
    doubleList(){  
        this->head= nullptr;  
        this->tail= nullptr;  
        this->size = 0;  
    }  
    void pushBack(doubleNode* node){  
        //// 这个点在不在链表里  
        // 一个点都没有  
        if (head == nullptr){  
            head = node;  
            tail = node;  
            ++size;  
        } else {  
            node->next = tail;  
            tail->pre = node;  
            tail = node;  
            ++ size;  
        }  
  
    }  
    void moveToTail(doubleNode* node){  
        //不只一个点 & 这个点不在尾部  
        if (node->pre!= nullptr){  
            //恰好那个点是头部,node->next = = nullptr  
            if(node == head){  
                head = node->pre;  
                node->pre->next=node->next;  
//                node->next->pre = node->pre;  
                node->next = tail;  
                node->pre = nullptr;  
                tail->pre = node;  
                tail = node;  
            }  
            else{  
                node->pre->next=node->next;  
                node->next->pre = node->pre;  
                node->next = tail;  
                node->pre = nullptr;  
                tail->pre = node;  
                tail = node;  
            }  
  
        }  
    };  
    void removeHead(){  
        doubleNode* pre = head->pre;  
        // 不止一个点  
        if (head->pre!= nullptr){  
            head->pre->next = nullptr;  
            head->pre = nullptr;  
            head->next = nullptr;  
        } else{  
            tail = nullptr;  
        }  
        delete head;  
        --size;  
        head = pre;  
    }  
  
  
};  
class LRUCache {  
public:  
    LRUCache(int capacity) {  
        this->capacity=capacity;  
        this->list = new doubleList();  
    }  
  
    bool containsKey(int key)  
    {  
        if (umap.find(key) == umap.end()) {  
            return false;  
        }  
        return true;  
    }  
  
    int get(int key) {  
        if (!containsKey(key)) {  
            return -1;  
        }  
        list->moveToTail(umap[key]);  
        return umap[key]->val;  
    }  
  
    void put(int key, int value) {  
        if(containsKey(key)){  
            umap[key]->val=value;  
            list->moveToTail(umap[key]);  
        } else{  
            doubleNode* node = new doubleNode(key,value);  
            if(list->size==capacity){  
                umap.erase(list->head->key);  
                list->removeHead();  
                list->pushBack(node);  
                umap.insert(pair<int,doubleNode*>(key,node));  
            } else{  
                list->pushBack(node);  
                umap.insert(pair<int,doubleNode*>(key,node));  
            }  
        }  
  
    }  
private:  
    int capacity;  
    doubleList* list;  
    unordered_map<int, doubleNode*> umap;  
};
```
## 插入、删除和获取随机元素O(1)时间的结构
[[常数时间插入、删除和获取随机元素]] 
插入abcde，get方法可以获取随机元素。 remove 不好实现，remove直接实现会导致连续数组有洞
方法：用最后一个补到挖出洞的位置
[测试链接](https://leetcode.cn/problems/insert-delete-getrandom-o1/)

==注意这里不该用map的，因为在c++里面map的时间复杂度是logn，应该用unordered_map==
我用错了，但懒得改了，leetcode没有测出来

```c++
// 插入、删除和获取随机元素O(1)时间的结构  
// 测试链接 : https://leetcode.cn/problems/insert-delete-getrandom-o1/class RandomizedSet {  
public:  
    RandomizedSet() {  
        this->count=0;  
        srand((unsigned)time(NULL));  
    }  
  
    bool insert(int val) {  
        auto result = m.insert(pair<int,int>(val,count));  
        if (result.second){  
            v.push_back(val);  
            count++;  
            return true;  
        } else{  
            return false;  
        }  
    }  
  
    bool remove(int val) {  
        auto pos = m.find(val);  
        if (pos!=m.end()){  
            int vpos = pos->second;  
            v[vpos] = v[count-1];  
            m.find(v[vpos])->second=vpos;  
            v.pop_back();  
            m.erase(pos);  
            count--;  
            return true;  
        } else{  
            return false;  
        }  
  
    }  
  
    int getRandom() {  
        int randomIndex = rand()%v.size();  
        return v[randomIndex];  
    }  
    map<int,int> m;  
    vector<int> v;  
    int count;  
  
};
```
## 插入、删除和获取随机元素O(1)时间且允许有重复数字的结构
[[常数时间插入、删除和获取重复元素]] 
[测试链接](https://leetcode.cn/problems/insert-delete-getrandom-o1-duplicates-allowed/)
懒得改了，直接抄了leetcode的。用multimap<int,int>解决不了问题，因为步伐稳定获取正确的对应位置的key。用unordered_set\<int\> 就可以解决问题
```c++
class RandomizedCollection {  
public:  
    unordered_map<int, unordered_set<int>> idx;  
    vector<int> nums;  
  
    /** Initialize your data structure here. */  
    RandomizedCollection() {  
  
    }  
  
    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */  
    bool insert(int val) {  
        nums.push_back(val);  
        idx[val].insert(nums.size() - 1);  
        return idx[val].size() == 1;  
    }  
  
    /** Removes a value from the collection. Returns true if the collection contained the specified element. */  
    bool remove(int val) {  
        if (idx.find(val) == idx.end()) {  
            return false;  
        }  
        int i = *(idx[val].begin());  
        nums[i] = nums.back();  
        idx[val].erase(i);  
        idx[nums[i]].erase(nums.size() - 1);  
        //最后一个直接删不需要插入  
        if (i < nums.size() - 1) {  
            idx[nums[i]].insert(i);  
        }  
        if (idx[val].size() == 0) {  
            idx.erase(val);  
        }  
        nums.pop_back();  
        return true;  
    }  
  
    /** Get a random element from the collection. */  
    int getRandom() {  
        return nums[rand() % nums.size()];  
    }  
};
```
## 快速获得数据流的中位数的结构
[[数据流的中位数]]
[测试链接](https://leetcode-cn.com/problems/find-median-from-data-stream)
用两个堆来管理数据，一个大根堆，存较小的数据，一个小根堆村较大的数据。各自的堆要存一半，所以需要balance操作。当一边的size比另外一边大超过or等于2的时候，需要重新balance。这样，看两个头就可以获得中位数了。
```c++
class MedianFinder {  
public:  
    priority_queue<int> maxHeap;  
    priority_queue<int, vector<int>, greater<int>> minHeap;  
    MedianFinder() {  
  
    }  
  
    void addNum(int num) {  
        if(maxHeap.empty()){  
            maxHeap.push(num);  
        }else if(num<=maxHeap.top()){  
            maxHeap.push(num);  
        }else{  
            minHeap.push(num);  
        }  
        balance();  
    }  
  
    double findMedian() {  
        if(minHeap.empty()){return maxHeap.top(); }  
        if(maxHeap.size()==minHeap.size()){  
            return (maxHeap.top()+minHeap.top())/2.0;  
        } else if (maxHeap.size()>minHeap.size()){  
            return maxHeap.top();  
        } else{  
            return minHeap.top();  
        }  
    }  
    void balance(){  
        if (maxHeap.size()-minHeap.size() == 2 ){  
            minHeap.push(maxHeap.top());  
            maxHeap.pop();  
        }else if(maxHeap.size()-minHeap.size()==-2){  
            maxHeap.push(minHeap.top());  
            minHeap.pop();  
        }  
    }  
};
```

## 最大频率栈
[[最大频率栈]]
[测试链接](https://leetcode.cn/problems/maximum-frequency-stack/)
设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出**出现频率**最高的元素。
使用map（词频表）+最大次记录
注意stack的设计的时候，设计成每一个层都是一个链表，链表存对应词频的数
![[Pasted image 20240712110918.png]]
```c++
// 最大频率栈  
// 测试链接 : https://leetcode.cn/problems/maximum-frequency-stack/class FreqStack {  
public:  
    FreqStack() {  
        maxFre=0;  
    }  
  
    void push(int val) {  
        if(m.find(val)!=m.end()){  
            m[val]+=1;  
            if(m[val]>maxFre){  
                maxFre = m[val];  
                cntMap.insert(pair<int, vector<int>>(maxFre,vector<int>()));  
                cntMap[m[val]].push_back(val);  
            } else{  
                cntMap[m[val]].push_back(val);  
            }  
        }else{  
            m.insert(pair<int,int>(val,1));  
            if(m[val]>maxFre){  
                maxFre = m[val];  
                cntMap.insert(pair<int, vector<int>>(maxFre,vector<int>()));  
                cntMap[m[val]].push_back(val);  
            } else{  
                cntMap[m[val]].push_back(val);  
            }  
        }  
    }  
  
    int pop() {  
        int n= cntMap[maxFre].back();  
        cntMap[maxFre].pop_back();  
        if (cntMap[maxFre].empty()){  
            cntMap.erase(maxFre);  
            --maxFre;  
        }  
        if( --m[n]==0){  
            m.erase(n);  
        }  
        return n;  
    }  
    unordered_map<int,vector<int>> cntMap;  
    unordered_map<int,int> m;  
    int maxFre;  
};
```
## 全O(1)的数据结构
[[全O(1)的数据结构]]
[测试链接](https://leetcode.cn/problems/all-oone-data-structure/)
请你设计一个用于存储字符串计数的数据结构，并能够返回计数最小和最大的字符串。
老师课上说的是用一个hash表+一个桶的双向链表
其实和上一题很像。桶就是hash，两个hash表也可以做(不能)。一定要使用双向链表才可以做，如果是用set来做，无法做到方便正常的再多种情况下切换min索引，因为删了一个set之后，不知道指向这个set的min该向小的数动还是大的数动，无法找到下一个数，但是双向链表可以
```c++
class Bucket {  
public:  
    set<string> set;  
    int cnt;  
    Bucket* last;  
    Bucket* next;  
  
    Bucket(const string& s, int c) {  
        set.insert(s);  
        cnt = c;  
    }  
};  
class AllOne {  
public:  
    Bucket* head;  
  
    Bucket* tail;  
  
    unordered_map<string , Bucket*> umap;  
    AllOne() {  
        head = new Bucket("", 0);  
        tail = new Bucket("", 2147483647);  
        head->next = tail;  
        tail->last = head;  
    }  
  
    void insert(Bucket* cur, Bucket* pos) {  
        cur->next->last = pos;  
        pos->next = cur->next;  
        cur->next = pos;  
        pos->last = cur;  
    }  
  
    void remove(Bucket* cur) {  
        cur->last->next = cur->next;  
        cur->next->last = cur->last;  
        delete cur;  
    }  
  
    bool containsKey(string key){  
        if(umap.find(key)!=umap.end()){  
            return true;  
        }  
        return false;  
    }  
    void inc(string key) {  
        if (!containsKey(key)) {  
            if (head->next->cnt == 1) {  
                umap.insert(pair<string, Bucket*>(key, head->next));  
                head->next->set.insert(key);  
            } else {  
                Bucket * newBucket = new Bucket(key, 1);  
                umap.insert(pair<string, Bucket*>(key, newBucket));  
                insert(head, newBucket);  
            }  
        } else {  
            Bucket* bucket = umap[key];  
            if (bucket->next->cnt == bucket->cnt + 1) {  
                umap[key] = bucket->next;  
//                umap.insert(pair<string, Bucket*>(key, bucket->next));  
                bucket->next->set.insert(key);  
            } else {  
                Bucket* newBucket = new Bucket(key, bucket->cnt + 1);  
                umap[key] = newBucket;  
//                umap.insert(pair<string, Bucket*>(key, newBucket));  
                insert(bucket, newBucket);  
            }  
            bucket->set.erase(key);  
            if (bucket->set.empty()) {  
                remove(bucket);  
            }  
        }  
    }  
  
    void dec(string key) {  
        Bucket* bucket = umap[key];  
        if (bucket->cnt == 1) {  
            umap.erase(key);  
        } else {  
            if (bucket->last->cnt == bucket->cnt - 1) {  
                umap[key] = bucket->last;  
//                umap.insert(pair<string, Bucket*>(key, bucket->last));  
                bucket->last->set.insert(key);  
            } else {  
                Bucket* newBucket = new Bucket(key, bucket->cnt - 1);  
                umap[key] = newBucket;  
//                umap.insert(pair<string, Bucket*>(key, newBucket));  
                insert(bucket->last, newBucket);  
            }  
        }  
        bucket->set.erase(key);  
        if (bucket->set.empty()) {  
            remove(bucket);  
        }  
    }  
  
    string getMaxKey() {  
        return *tail->last->set.begin();  
    }  
  
    string getMinKey() {  
        return *head->next->set.begin();  
    }  
  
};
```


# 二叉树经典问题
## 层序遍历(bfs)
[[二叉树的层序遍历]]
[[二叉树按层遍历并收集节点]]
[测试链接](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

### 按层收集结点
多一个表，记录自己在哪个层，普通的bfs，一个一个处理。用map处理第几层
```c++
vector<vector<int>> levelOrder(TreeNode* root) {  
    vector<vector<int>> ans;  
    unordered_map<TreeNode*,int> umap;  
    if (root!= nullptr){  
        queue<TreeNode*> q;  
        TreeNode* temp;  
        ans.emplace_back();  
        ans[0].push_back(root->val);  
        q.push(root);  
        int level = 0;  
        umap.insert(pair<TreeNode*, int>(root,level));  
        while (!q.empty()){  
            temp = q.front();  
            if(temp->left!= nullptr){  
                q.push(temp->left);  
                umap.insert(pair<TreeNode*, int>(temp->left,umap[temp]+1));  
                if (ans.size()<=umap[temp]+1){  
                    ans.emplace_back();  
                }  
                ans[umap[temp]+1].push_back(temp->left->val);  
            }  
            if(temp->right!= nullptr){  
                q.push(temp->right);  
                umap.insert(pair<TreeNode*, int>(temp->right,umap[temp]+1));  
                if (ans.size()<=umap[temp]+1){  
                    ans.emplace_back();  
                }  
                ans[umap[temp]+1].push_back(temp->right->val);  
            }  
            q.pop();  
        }  
    }  
    return ans;  
}
```
### 用数组模拟队列
此方法为每次处理一层的优化bfs，此题推荐。因为没用数组，用了vector，所以时间上的损耗较大，但是原理是一样的
```c++
vector<vector<int>> levelOrder2(TreeNode* root) {  
//    树中节点数目在范围 [0, 2000] 内，通过l和r控制每一层  
    vector<vector<int>> ans;  
    if(root!= nullptr){  
        int l,r,level;  
        l = level = 0;  
        r = 1;  
        vector<TreeNode*> q;  
        q.push_back(root);  
        while (l<r){  
            ans.emplace_back();  
            for (int i = l; i <r ; ++i) {  
                ans[level].push_back(q[i]->val);  
                if(q[i]->left!= nullptr){  
                    q.push_back(q[i]->left);  
                }  
                if(q[i]->right!= nullptr){  
                    q.push_back(q[i]->right);  
                }  
            }  
            ++level;  
            l = r;  
            r = q.size();  
        }  
    }  
    return ans;  
}
```
## 锯齿型层序遍历
[[二叉树的锯齿形层次遍历]]
从左往右->从右往左->从左往右
用数组模拟队列的方法做比较方便，因为可以一次处理一层
[测试链接](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal)
没什么特别的，多反一下就好了
```c++
vector<vector<int>> zigzagLevelOrder(TreeNode* root) {  
    vector<vector<int>> ans;  
    if(root!= nullptr){  
        int l,r,level;  
        l = level = 0;  
        r = 1;  
        vector<TreeNode*> q;  
        q.push_back(root);  
        while (l<r){  
            ans.emplace_back();  
            if(level%2 ==0){  
                for (int i = l; i <r ; ++i) {  
                    ans[level].push_back(q[i]->val);  
                    if(q[i]->left!= nullptr){  
                        q.push_back(q[i]->left);  
                    }  
                    if(q[i]->right!= nullptr){  
                        q.push_back(q[i]->right);  
                    }  
                }  
            } else{  
                for (int i = r-1; i >=l ; --i) {  
                    ans[level].push_back(q[i]->val);  
                }  
                for (int i = l; i <r ; ++i) {  
                    if(q[i]->left!= nullptr){  
                        q.push_back(q[i]->left);  
                    }  
                    if(q[i]->right!= nullptr){  
                        q.push_back(q[i]->right);  
                    }  
                }  
            }  
  
            ++level;  
            l = r;  
            r = q.size();  
        }  
    }  
    return ans;  
}
```

## 二叉树最大特殊宽度
[[二叉树最大特殊宽度]]
 从左往右第一个不为null
 可以把它看成完全二叉树，利用编号计算宽度
 [测试链接](https://leetcode.cn/problems/maximum-width-of-binary-tree/)
 ```c++
 // 二叉树的最大特殊宽度  
// 测试链接 : https://leetcode.cn/problems/maximum-width-of-binary-tree/int widthOfBinaryTree(TreeNode* root) {  
//    vector<vector<int>> ans;  
    int size =0;  
    if(root!= nullptr){  
        int l,r;  
        l = 0;  
        r = 1;  
  
        vector<pair<TreeNode*,unsigned long long>> q;  
        q.push_back(pair<TreeNode*,unsigned long long>(root,1));  
        while (l < r){  
            for (int i = l; i <r ; ++i) {  
                if(q[i].first->left!= nullptr){  
                    q.emplace_back(q[i].first->left,q[i].second*2);  
                }  
                if (q[i].first->right!= nullptr){  
                    q.emplace_back(q[i].first->right,q[i].second * 2+1);  
                }  
  
            }  
            if(size < q[r-1].second - q[l].second + 1 ){  
                size = q[r-1].second- q[l].second + 1;  
            }  
            l = r;  
            r = q.size();  
        }  
    }  
    return size;  
}
```
## 二叉树最大深度
[[二叉树的最大深度]]
[[返回一棵树的最大深度]]
[测试链接](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)
```c++
int maxDepth(TreeNode* root) {  
    return root == nullptr ? 0 : max(maxDepth(root->left), maxDepth(root->right))+1;  
}
```
## 二叉树最小深度
碰到叶节点的最小深度
小心孩子为空对答案的干扰，弄成整数最大
[[二叉树的最小深度]]
[测试链接]( https://leetcode.cn/problems/minimum-depth-of-binary-tree/)
注意要是判断是不是叶子结点
```c++
int minDepth(TreeNode* root) {  
    // 一定要扎到叶节点  
    if (root == nullptr) {  
        // 当前的树是空树  
        return 0;  
    }  
    if (root->left == nullptr && root->right == nullptr) {  
        // 当前root是叶节点  
        return 1;  
    }  
    unsigned int temp = 1u << 31;  
    int max_int = temp - 1;  
    int ldeep = max_int;  
    int rdeep = max_int;  
    if (root->left != nullptr) {  
        ldeep = minDepth(root->left);  
    }  
    if (root->right != nullptr) {  
        rdeep = minDepth(root->right);  
    }  
    return min(ldeep, rdeep) + 1;  
}
```
## 二叉树的序列化和反序列化
不存在中序的序列化，因为序列化的结果不唯一
[[序列化和反序列化 N 叉树]]
### 先序序列化/反序列化
后序类似
[测试链接](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)
```c++
class Codec {  
public:  
    void f(TreeNode* root, string& s){  
        if (root == nullptr){  
            s +="None,";  
        } else{  
            s += to_string(root->val) + ",";  
            f(root->left,s);  
            f(root->right,s);  
        }  
    }  
  
    // Encodes a tree to a single string.  
    string serialize(TreeNode* root) {  
        string s;  
        f(root,s);  
        return s;  
  
    }  
    TreeNode* g(list<string>& dataArray){  
        if (dataArray.front() == "None") {  
            dataArray.erase(dataArray.begin());  
            return nullptr;  
        }  
        TreeNode* root = new TreeNode(stoi(dataArray.front()));  
        dataArray.erase(dataArray.begin());  
        root->left = g(dataArray);  
        root->right = g(dataArray);  
        return root;  
  
    }  
    // Decodes your encoded data to tree.  
    TreeNode* deserialize(string data) {  
        list<string> dataArray;  
        string str;  
        for (auto& ch : data) {  
            if (ch == ',') {  
                dataArray.push_back(str);  
                str.clear();  
            } else {  
                str.push_back(ch);  
            }  
        }  
        if (!str.empty()) {  
            dataArray.push_back(str);  
            str.clear();  
        }  
        return g(dataArray);  
    }  
};
```
### 按层进行序列化和反序列化
继续使用队列进行序列化
[测试链接](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)
注意特殊情况，头为空指针
```c++
class Codec {  
public:  
    void f(TreeNode* root, string& s){  
        queue<TreeNode*> q;  
        q.push(root);  
        while (!q.empty()){  
            if (q.front() == nullptr){  
                s += "None,";  
            } else {  
                s += to_string(q.front()->val) + ",";  
                q.push(q.front()->left);  
                q.push(q.front()->right);  
            }  
            q.pop();  
        }  
    }  
  
    // Encodes a tree to a single string.  
    string serialize(TreeNode* root) {  
        string s;  
        f(root, s);  
        return s;  
    }  
  
    TreeNode* generate(string val) {  
        return val == "None" ? nullptr : new TreeNode(stoi(val));  
    }  
  
    TreeNode* g(vector<string>& v){  
        int index = 0;  
        TreeNode* root = generate(v[index++]);  
        if(root == nullptr){  
            return nullptr;  
        }  
        vector<TreeNode*> que;  
        int l, r;  
        l = r = 0;  
        que.push_back(root);  
        r++;  
  
        while (l < r) {  
            TreeNode* cur = que[l++];  
            cur->left = generate(v[index++]);  
            cur->right = generate(v[index++]);  
            if (cur->left != nullptr) {  
                que.push_back(cur->left);  
                r++;  
            }  
            if (cur->right != nullptr) {  
                que.push_back(cur->right);  
                r++;  
            }  
        }  
        return root;  
    }  
  
    // Decodes your encoded data to tree.  
    TreeNode* deserialize(string data) {  
        vector<string> l;  
        string s;  
        for (auto c : data) {  
            if (c == ',') {  
                l.push_back(s);  
                s.clear();  
            } else {  
                s.push_back(c);  
            }  
        }  
        if (!s.empty()) {  
            l.push_back(s);  
            s.clear();  
        }  
        return g(l);  
    }  
};
```
## 先序和中序遍历构造二叉树
[[从前序与中序遍历序列构造二叉树]] 
测试链接 : https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/
注意map写的时候引用传递，不然时间会超出
``` c++
TreeNode* rbuildTree(vector<int>& preorder,int l1, int r1, vector<int>& inorder,int l2, int r2,unordered_map<int,int>& umap){  
    if(l1>r1){  
        return nullptr;  
    }  
    TreeNode* root = new TreeNode(preorder[l1]);  
    int mid = umap[preorder[l1]];  
    if(l1==r1){  
        return root;  
    } else{  
        root->left =rbuildTree(preorder,l1+1,l1+mid-l2,inorder,l2,mid-1,umap);  
        root->right = rbuildTree(preorder,l1+mid-l2+1, r1,inorder,mid+1,r2,umap);  
    }  
  
    return root;  
}  
TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {  
    if (preorder.empty()||inorder.empty()||inorder.size()!=preorder.size()){  
        return nullptr;  
    }  
    unordered_map<int,int> umap;  
    for (int i = 0; i < inorder.size(); ++i) {  
        umap.insert(pair<int,int>(inorder[i],i));  
    }  
    return rbuildTree(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1,umap);  
}
```
## 验证完全二叉树
1) 有右无左 ❌
2) 如果孩子不双全，那么孩子一定要是叶节点
[[判断二叉树是不是完全二叉树]]
测试链接 : https://leetcode.cn/problems/check-completeness-of-a-binary-tree/
```c++
bool isCompleteTree(TreeNode* root) {  
    vector<TreeNode*> que;  
    int l,r;  
    l = r = 0;  
    que.push_back(root);  
    r++;  
    // 是否遇到过左右两个孩子不双全的节点  
    bool leaf = false;  
    while (l<r){  
        TreeNode * root = que[l++];  
        if( root->left == nullptr && root->right!= nullptr){  
            return false;  
        } else if(leaf && (root->left != nullptr || root->right != nullptr)){  
            return false;  
        }else{  
            if (root->left!= nullptr){  
                que.push_back(root->left);  
                r++;  
            }  
            if(root->right!= nullptr){  
                que.push_back(root->right);  
                r++;  
            }  
            if (root->left == nullptr || root->right == nullptr) {  
                leaf = true;  
            }  
        }  
    }  
    return true;  
}
```
## 求完全二叉树的节点个数
[[求完全二叉树节点的个数]]
[测试链接]( https://leetcode.cn/problems/count-complete-tree-nodes/)
```c++
int mostLeft(TreeNode* cur, int level) {  
    while (cur != nullptr) {  
        level++;  
        cur = cur->left;  
    }  
    return level - 1;  
}  
// cur : 当前来到的节点  
// level :  当前来到的节点在第几层  
// h : 整棵树的高度，不是cur这棵子树的高度  
// 求 : cur这棵子树上有多少节点  
int f(TreeNode *cur, int level, int h) {  
    if (level == h) {  
        return 1;  
    }  
    if (mostLeft(cur->right, level + 1) == h) {  
        // cur右树上的最左节点，扎到了最深层  
        return (1 << (h - level)) + f(cur->right, level + 1, h);  
    } else {  
        // cur右树上的最左节点，没扎到最深层  
        return (1 << (h - level - 1)) + f(cur->left, level + 1, h);  
    }  
}  
int countNodes(TreeNode* root) {  
    if (root == nullptr) {  
        return 0;  
    }  
    return f(root, 1, mostLeft(root, 1));  
}
```