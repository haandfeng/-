#滑动窗口 #双指针 
双指针：
满足了单调性，从满足要求到不满足要求 or 相反
# [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

[[长度最小的子数组]]
## 暴力做法
从0开始，不断枚举<target就向右走，大于就+1
时间复杂度O(N^2)

## 滑动窗口（保留上一次的计算结果）
利用数组都是正数的性质
时间复杂度O(N)

枚举子数组右端点，可以少写一些判断条件
```c++
int minSubArrayLen(int target, vector<int>& nums) {  
    int result = nums.size()+1;  
    int cur = 0;  
    int right =0;  
    int left=0;  
    while (right < nums.size()) {
		// 一直加  
        cur += nums[right];  
        // 知道遇到大于等于的情况，说明遇到了结果，这个时候残更新result
        while (cur > target || cur == target) {  
            result = min(result, right - left +1);  
            cur -= nums[left++];  
        }  
        ++right;  
    }  
    // result 没更新，说明不存在结果
    return result == nums.size()+1 ? 0 : result;  
}
```

0x3f
```c++
    int minSubArrayLen(int target, vector<int>& nums) {
        int n = nums.size(), ans = n + 1, sum = 0, left = 0;
        for (int right = 0; right < n; right++) { // 枚举子数组右端点
            sum += nums[right];
            while (sum >= target) { // 满足要求
                ans = min(ans, right - left + 1);
                sum -= nums[left++]; // 左端点右移
            }
        }
        return ans <= n ? ans : 0;
    }
```
# [713. 乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/)

方法和上一题一样
我觉得这道题的难点，我卡住的地方，还是怎么看出单调性，利用单调性统计数据->这里每一次滑动窗口，存在多少个可能的答案的统计。 卡在这一部很久

可以理解成:枚举到某一个数，以某一个数为右端点满足条件的数目
```c++
int numSubarrayProductLessThanK(vector<int>& nums, int k) {  
    int result = 0;  
    int left = 0, right = 0;  
    int cur=1;  
    while (right < nums.size()) {  
        cur *= nums[right];  
        while (cur >= k && left<=right) {  
            cur/=nums[left++];  
        }  
        result += right - left+1;  
        ++right;  
    }  
    return result;  
}
```

0x3f

```c++
class Solution {
public:
    int numSubarrayProductLessThanK(vector<int> &nums, int k) {
        if (k <= 1) {
            return 0;
        }
        int ans = 0, prod = 1, left = 0;
        for (int right = 0; right < nums.size(); right++) {
            prod *= nums[right];
            while (prod >= k) { // 不满足要求
                prod /= nums[left++];
            }
            ans += right - left + 1;
        }
        return ans;
    }
};
```
# [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

[[无重复字符的最长子串]]

因为不是很会c++的哈希表，但思路比较懂，所以直接用了0x3f的思路
```c++
int lengthOfLongestSubstring(string s) {  
    int n = s.length(), ans = 0, left = 0;  
    unordered_set<char> window; // 维护从下标 left 到下标 right 的字符  
    for (int right = 0; right < n; right++) {  
        char c = s[right];  
        // 如果窗口内已经包含 c，那么再加入一个 c 会导致窗口内有重复元素  
        // 所以要在加入 c 之前，先移出窗口内的 c        while (window.contains(c)) { // 窗口内有 c            window.erase(s[left]);  
            left++; // 缩小窗口  
        }  
        window.insert(c); // 加入 c        ans = max(ans, right - left + 1); // 更新窗口长度最大值  
    }  
    return ans;  
}
```