#0x3f  #二叉树 #二叉树遍历 #二叉树的递归套路 

递归：
	递：从原问题出发，把问题分解成更小的子问题（思考整棵树和左右子树的关系）
	归：递下去的尽头（边界条件），返回答案，但要思考自身，和子问题的关系
# [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)
[[二叉树的最大深度]]
## 自底向上
```c++
int maxDepth(TreeNode* root) {  
    if (root == nullptr) return 0;  
    int left = maxDepth(root->left);  
    int right = maxDepth(root->right);  
    return max(left, right) + 1;  
}
```

## 自顶向下
3. `auto dfs = [&](this auto&& dfs, TreeNode* node, int depth) -> void`定义了一个递归的匿名函数 dfs，采用 C++14 引入的**泛型 Lambda**，允许在 Lambda 内部进行递归调用。

• this auto&& dfs：这是 Lambda 参数列表中的 **递归 Lambda 本身**，类似于函数指针，用于递归调用自身。

• TreeNode* node：当前递归遍历到的二叉树节点。

• int depth：当前递归的深度。

• -> void：表示 dfs 的返回类型是 void。


```c++
int maxDepth(TreeNode* root) {  
    int ans = 0;  
    auto dfs = [&](this auto&& dfs, TreeNode* node, int depth) -> void {  [
]()        if (node == nullptr) {  
            return;  
        }  
        depth++;  
        ans = max(ans, depth);  
        dfs(node->left, depth);  
        dfs(node->right, depth);  
    };  
    dfs(root, 0);  
    return ans;  
}
```

# [111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)
和最大深度差不多，可是要注意特殊情况，左子树或者右子树一边全部为空的时候，不能考虑他的高度为0 
```c++
int minDepth(TreeNode* root) {  
    if (root == nullptr) return 0;  
    int left = minDepth(root->left);  
    int right = minDepth(root->right);  
    if (left == 0) {return right+1;}  
    if (right == 0) {return left+1;}  
    return min(left, right)+1;  
}
```


# [112. 路径总和](https://leetcode.cn/problems/path-sum/)

注意要判断是不是叶子节点，我审错题目了，还有题目给的函数没能传递sum，要传递
```c++
bool getSum(TreeNode* root, int sum, int target) {  
    if (root == nullptr) return false;  
    sum += root->val;  
    if (sum == target && root->left==nullptr && root->right==nullptr) {return true;}  
    return getSum(root->left, sum, target) || getSum(root->right, sum, target);  
}  
bool hasPathSum(TreeNode* root, int targetSum) {  
    if (root == nullptr) return false;  
    int sum = 0;  
    return  getSum(root,sum,targetSum);  
}
```

0x3f
比我的简单，可以用删除，就倒着减少了
```c++
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if (root == nullptr) {
            return false;
        }
        targetSum -= root->val;
        if (root->left == root->right) { // root 是叶子
            return targetSum == 0;
        }
        return hasPathSum(root->left, targetSum) || hasPathSum(root->right, targetSum);
    }
};
```

# [129. 求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)

我认为用到了回溯的思想，把所有的可能的路径都加到了结果数组里面，然后计算结果
```c++
int getSum(vector<vector<int>> &allNumbers) {  
    int sum = 0;  
    for (int i = 0; i < allNumbers.size(); i++) {  
        long long mul = 1;  
        for (int j = allNumbers[i].size()-1 ; j >= 0; --j) {  
            sum += allNumbers[i][j]*mul;  
            mul *= 10;  
        }  
    }  
    return sum;  
}  
  
void getVector(vector<vector<int>> &allNumbers,TreeNode* root, vector<int>& now) {  
    if (root == nullptr) return;  
    now.push_back(root->val);  
    getVector(allNumbers, root->left,now);  
    getVector(allNumbers, root->right,now);  
    if (root->left==nullptr && root->right==nullptr) {  
        allNumbers.push_back(now);  
    }  
    now.pop_back();  
}  
int sumNumbers(TreeNode* root) {  
    vector<vector<int>> allNumbers;  
    vector<int> now;  
    getVector(allNumbers,root,now);  
    return getSum(allNumbers);  
}
```

0x3f

他对遍历到的数计算比我好，我对于信息的利用率太低了
对于路径 4→9→5，我们可以按照如下方式生成数字 495。

初始化 x=0。
从 4 开始递归，更新 x=x⋅10+4=4。
向下递归到 9，更新 x=x⋅10+9=49。
向下递归到 5，更新 x=x⋅10+5=495。


dfs没返回值
```c++
class Solution {
    int ans = 0;

    void dfs(TreeNode *node, int x) {
        if (node == nullptr) {
            return;
        }
        x = x * 10 + node->val;
        if (node->left == node->right) { // node 是叶子节点
            ans += x;
            return;
        }
        dfs(node->left, x);
        dfs(node->right, x);
    }

public:
    int sumNumbers(TreeNode *root) {
        dfs(root, 0);
        return ans;
    }
};
```


dfs有返回值
```c++
class Solution {
public:
    int sumNumbers(TreeNode *root, int x = 0) {
        if (root == nullptr) {
            return 0;
        }
        x = x * 10 + root->val;
        if (root->left == root->right) { // root 是叶子节点
            return x;
        }
        return sumNumbers(root->left, x) + sumNumbers(root->right, x);
    }
};
```

# [1448. 统计二叉树中好节点的数目](https://leetcode.cn/problems/count-good-nodes-in-binary-tree/)
解决的子问题是：
	已只max，判断自己是不是好节点，获得左子树有多少个好节点，右子树有多少个好节点
边界条件是：
	null返回0
```c++
int gN(TreeNode* root, int max) {  
    if (root == nullptr) return 0;  
    if (root->val >= max) {  
        max = root->val;  
        return gN(root->right, max)+gN(root->left,max)+1;  
    }  
    return gN(root->left, max)+gN(root->right,max);  
}  
int goodNodes(TreeNode* root) {  
    return gN(root,INT_MIN);  
}
```

0x3f
思路一致
```c++
class Solution {
public:
    int goodNodes(TreeNode *root, int mx = INT_MIN) {
        if (root == nullptr)
            return 0;
        int left = goodNodes(root->left, max(mx, root->val));
        int right = goodNodes(root->right, max(mx, root->val));
        return left + right + (mx <= root->val);
    }
};
```
# [987. 二叉树的垂序遍历](https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/)

有点懒了，而且处理结果的方法不好写，所以我选择直接看0x3f的思路。。


在 DFS 的同时，用一个哈希表（或者有序字典）来记录这些数据。哈希表的 key 是 col，哈希表的 value 是一个列表，列表中保存 (row,val) 二元组。

DFS 结束后，按照 key 从小到大遍历哈希表，对于哈希表的每个 value，把 value 中的二元组排序，最后取出 value 中的 val 加入答案

## 写法一
和我的想法差不多，但我觉得写得很麻烦
```c++
class Solution {
    map<int, vector<pair<int, int>>> groups;

    void dfs(TreeNode *node, int row, int col) {
        if (node == nullptr) {
            return;
        }
        // col 相同的分到同一组
        groups[col].emplace_back(row, node->val);
        dfs(node->left, row + 1, col - 1);
        dfs(node->right, row + 1, col + 1);
    }

public:
    vector<vector<int>> verticalTraversal(TreeNode *root) {
        dfs(root, 0, 0);
        vector<vector<int>> ans;
        for (auto &[_, g] : groups) {
            ranges::sort(g);
            vector<int> vals;
            for (auto &[_, val] : g) {
                vals.push_back(val);
            }
            ans.push_back(vals);
        }
        return ans;
    }
};
```

## 写法二
也可以在 DFS 的同时记录 col 的最小值，这样无需对 key 排序，也无需使用有序字典。
	所以可以用 `unordered_map` 加快运行效率
```c++
class Solution {
    unordered_map<int, vector<pair<int, int>>> groups;
    int min_col = 0;

    void dfs(TreeNode *node, int row, int col) {
        if (node == nullptr) {
            return;
        }
        min_col = min(min_col, col);
        groups[col].emplace_back(row, node->val);
        dfs(node->left, row + 1, col - 1);
        dfs(node->right, row + 1, col + 1);
    }

public:
    vector<vector<int>> verticalTraversal(TreeNode *root) {
        dfs(root, 0, 0);
        vector<vector<int>> ans;
        for (int i = min_col; i < min_col + (int) groups.size(); i++) {
            auto &g = groups[i];
            ranges::sort(g);
            vector<int> vals;
            for (auto &[_, val] : g) {
                vals.push_back(val);
            }
            ans.push_back(vals);
        }
        return ans;
    }
};
```

## 写法三
也可以用两个列表记录数据，一个列表 left 负责统计负数 col，另一个列表 right 负责统计非负数 col。
这样就可以不用map了
```c++
class Solution {
public:
    vector<vector<int>> verticalTraversal(TreeNode *root) {
        vector<vector<pair<int, int>>> left, right;
        function<void(TreeNode*, int, int)> dfs = [&](TreeNode *node, int row, int col) {
            if (node == nullptr) {
                return;
            }
            if (col < -(int) left.size()) {
                left.push_back({});
            } else if (col == right.size()) {
                right.push_back({});
            }
            (col < 0 ? left[-col - 1] : right[col]).emplace_back(row, node->val);
            dfs(node->left, row + 1, col - 1);
            dfs(node->right, row + 1, col + 1);
        };
        dfs(root, 0, 0);

        vector<vector<int>> ans;
        auto add = [&](vector<vector<pair<int, int>>> &a) {
            for (auto &g : a) {
                ranges::sort(g);
                vector<int> vals;
                for (auto &[_, val] : g) {
                    vals.push_back(val);
                }
                ans.push_back(vals);
            }
        };
        ranges::reverse(left);
        add(left);
        add(right);
        return ans;
    }
};
```

##  写法四

```c++
class Solution {
public:
    vector<vector<int>> verticalTraversal(TreeNode *root) {
        vector<tuple<int, int, int>> data;
        function<void(TreeNode*, int, int)> dfs = [&](TreeNode *node, int row, int col) {
            if (node == nullptr) {
                return;
            }
            data.emplace_back(col, row, node->val);
            dfs(node->left, row + 1, col - 1);
            dfs(node->right, row + 1, col + 1);
        };
        dfs(root, 0, 0);

        vector<vector<int>> ans;
        // std::tuple 的排序是按照 **字典序** 进行的，即
        ranges::sort(data);
        int last_col = INT_MIN;
        for (auto &[col, _, val]: data) {
            if (col != last_col) {
                last_col = col;
                ans.push_back({});
            }
            ans.back().push_back(val);
        }
        return ans;
    }
};
```
# [100. 相同的树](https://leetcode.cn/problems/same-tree/)
[[判断两颗树是否结构相同]]
解决的子问题是：
	左边两颗子树树否相同和右边两颗子树是否相同
边界条件是：
	是两颗树有一个是空的，就要判断是不是两个都是空
```c++
bool isSameTree(TreeNode* p, TreeNode* q) {  
    if (p == nullptr && q == nullptr) return true;  
    if (p == nullptr || q == nullptr) return false;  
    if (p->val != q->val) return false;  
    // 只要不存在val不相等的情况，这个一定返回true，所以不需要p->val == q->val
    return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);  
}
```

0x3f
```c++
class Solution {
public:
    bool isSameTree(TreeNode *p, TreeNode *q) {
        if (p == nullptr || q == nullptr)
            return p == q; // 必须都是 nullptr
        return p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
    }
};
```
# [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)
[[对称二叉树]]
解决的子问题是：
	拆成左右两颗树，看根节点是否相等，然后递归左边的左子树和右边的右子树对比
边界条件是：
	是两颗树有一个是空的，就要判断是不是两个都是空

```c++
bool isSameTree(TreeNode* p, TreeNode* q) {  
    if (p == nullptr && q == nullptr) return true;  
    if (p == nullptr || q == nullptr) return false;  
    if (p->val != q->val) return false;  
    return isSameTree(p->left,q->right) && isSameTree(p->right,q->left);  
}  
  
bool isSymmetric(TreeNode* root) {  
    return isSameTree(root->left,root->right);  
}
```

0x3f
```c++
class Solution {
    // 在【100. 相同的树】的基础上稍加改动
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if (p == nullptr || q == nullptr) {
            return p == q;
        }
        return p->val == q->val && isSameTree(p->left, q->right) && isSameTree(p->right, q->left);
    }

public:
    bool isSymmetric(TreeNode* root) {
        return isSameTree(root->left, root->right);
    }
};
```
# [110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)
[[判断是否是平衡搜索二叉树]]
[[判断二叉树是不是平衡二叉树]]
[[二叉树概念汇总#平衡二叉树|平衡二叉树]]
[[二叉树概念汇总#二叉搜索树- 搜索二叉树|搜索二叉树]]
平衡二叉树：左子树和有右子树的高度差不超过1
只要有一个子树不同，就立刻全部返回

解决的子问题是：
	拆成左右两颗树，看左数的高度差和右数的高度差
边界条件：
	节点为nullptr，要返回高度0，返回true
感觉我的很麻烦，浪费时间（重复获得高度了，就应该像0x3f的一样，每次递归的时候，就要获得判断结果是否符合要求）
```c++
int iB(TreeNode* root) {  
    if (root == nullptr) return 0;  
    return max(iB(root->left),iB(root->right))+1;  
}  
bool isBalanced(TreeNode* root) {  
    if (root == nullptr) return true;  
    int left = iB(root->left);  
    int right = iB(root->right);  
    return (abs(left-right)<=1)&& isBalanced(root->left) && isBalanced(root->right);  
}
```
0x3f
零神有了-1标记是否不平衡了，提高结果判断
一边获得树的高度， 一边判断大小
```c++
class Solution {
    int get_height(TreeNode *node) {
        if (node == nullptr) return 0;
        int leftH = get_height(node->left);
        if (leftH == -1) return -1; // 提前退出，不再递归
        int rightH = get_height(node->right);
        if (rightH == -1 || abs(leftH - rightH) > 1) return -1;
        return max(leftH, rightH) + 1;
    }

public:
    bool isBalanced(TreeNode *root) {
        return get_height(root) != -1;
    }
};

```
# [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)
要解决两个问题：
1. 怎么把答案记下来
2. 记录哪个节点为答案->递归深度=答案位置

右视图：优先遍历右子树


# [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)


# [617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)


# [1026. 节点与其祖先之间的最大差值](https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor/)


# [1080. 根到叶路径上的不足节点](https://leetcode.cn/problems/insufficient-nodes-in-root-to-leaf-paths/)


# [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)
[[搜索二叉树]] [[验证二叉搜索树]] [[判断二叉树是不是搜索二叉树]] 
任何一个节点为头的数, 左边的值都比头要小, 右边的数都比这个头要大

递归的时候确定范围
## 方法一

## 方法二

## 方法三



# [938. 二叉搜索树的范围和](https://leetcode.cn/problems/range-sum-of-bst/)

# [2476. 二叉搜索树最近节点查询](https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree/)

# [230. 二叉搜索树中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

# [1373. 二叉搜索子树的最大键值和](https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/)

# [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

# [106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

# [889. 根据前序和后序遍历构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)

# [1110. 删点成林](https://leetcode.cn/problems/delete-nodes-and-return-forest/)






# 左链接
[[二叉树经典问题]]
[[07 二叉树的基本算法]]
[[08 二叉树的递归套路]]
[[二叉树概念汇总]]
[[二叉树的递归套路]]
