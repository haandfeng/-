#0x3f  #二叉树 #二叉树遍历 #二叉树的递归套路 

递归：
	递：从原问题出发，把问题分解成更小的子问题
	归：递下去的尽头（边界条件），返回答案，但要思考自身，和子问题的关系
# [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)
[[二叉树的最大深度]]
## 自底向上
```c++
int maxDepth(TreeNode* root) {  
    if (root == nullptr) return 0;  
    int left = maxDepth(root->left);  
    int right = maxDepth(root->right);  
    return max(left, right) + 1;  
}
```

## 自顶向下
3. `auto dfs = [&](this auto&& dfs, TreeNode* node, int depth) -> void`定义了一个递归的匿名函数 dfs，采用 C++14 引入的**泛型 Lambda**，允许在 Lambda 内部进行递归调用。

• this auto&& dfs：这是 Lambda 参数列表中的 **递归 Lambda 本身**，类似于函数指针，用于递归调用自身。

• TreeNode* node：当前递归遍历到的二叉树节点。

• int depth：当前递归的深度。

• -> void：表示 dfs 的返回类型是 void。


```c++
int maxDepth(TreeNode* root) {  
    int ans = 0;  
    auto dfs = [&](this auto&& dfs, TreeNode* node, int depth) -> void {  [
]()        if (node == nullptr) {  
            return;  
        }  
        depth++;  
        ans = max(ans, depth);  
        dfs(node->left, depth);  
        dfs(node->right, depth);  
    };  
    dfs(root, 0);  
    return ans;  
}
```

# [111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)
和最大深度差不多，可是要注意特殊情况，左子树或者右子树一边全部为空的时候，不能考虑他的高度为0 
```c++
int minDepth(TreeNode* root) {  
    if (root == nullptr) return 0;  
    int left = minDepth(root->left);  
    int right = minDepth(root->right);  
    if (left == 0) {return right+1;}  
    if (right == 0) {return left+1;}  
    return min(left, right)+1;  
}
```


## [112. 路径总和](https://leetcode.cn/problems/path-sum/)
注意要判断是不是叶子节点，我审错题目了，还有题目给的函数没能传递sum，要传递
```c++
bool getSum(TreeNode* root, int sum, int target) {  
    if (root == nullptr) return false;  
    sum += root->val;  
    if (sum == target && root->left==nullptr && root->right==nullptr) {return true;}  
    return getSum(root->left, sum, target) || getSum(root->right, sum, target);  
}  
bool hasPathSum(TreeNode* root, int targetSum) {  
    if (root == nullptr) return false;  
    int sum = 0;  
    return  getSum(root,sum,targetSum);  
}
```

0x3f
比我的简单，可以用删除，就倒着减少了
```c++
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if (root == nullptr) {
            return false;
        }
        targetSum -= root->val;
        if (root->left == root->right) { // root 是叶子
            return targetSum == 0;
        }
        return hasPathSum(root->left, targetSum) || hasPathSum(root->right, targetSum);
    }
};
```
# 左链接
[[二叉树经典问题]]
[[07 二叉树的基本算法]]
[[08 二叉树的递归套路]]
[[二叉树概念汇总]]
[[二叉树的递归套路]]