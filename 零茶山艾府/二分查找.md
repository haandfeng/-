#0x3f  #二分 #二分法 

确保 一直在一个左闭右闭区间-> L = M+1 

找中间，防溢出-> left + (right-left)/2

==注意循环不变量==


转化：
\>  ==   >= x + 1    +1 表示 x右边的数
<  ==  (>=x) - 1  => -1 表示 x左边的数
<=  ==  (>x) -1   => -1 表示 x左边的数

```
我是在看了这篇文章，https://blog.csdn.net/groovy2007/article/details/78309120，里那句“关键不在于区间里的元素具有什么性质，而是区间外面的元素具有什么性质。”之后醍醐灌顶，建立了我自己的二分查找心智模型，和up主的有些类似。 

也就是看最终左右指针会停在哪里。 如果我们要找第一个大于等于x的位置，那么我就假设L最终会停在第一个大于等于x的位置，R停在L的左边。 这样按照上面那句话，可以把循环不变式描述为“L的左边恒小于x，R的右边恒大于等于x”，这样一来，其他的各种条件就不言自明了。 

比如循环条件肯定是L小于R，因为我假设R停在L的左边。 而L和R转移的时候，根据循环不变式，如果mid小于x，肯定要令L等于mid+1，如果大于等于x，就令R等于mid-1。 至于初始的时候L和R怎么选，也是看循环不变式，只需要保证初始L和R的选择满足“L的左边恒小于x，R的右边恒大于等于x”，并且不会出现越界的情况即可，L必为0，因为0左边可以看作负无穷，恒小于x，R取第一个一定满足条件的（防止mid取到非法值），例如n-1（n开始可以看作正无穷，恒大于等于x，如果保证x在数组里可以选择n-2，其实大于等于n也满足不变式，但是mid可能会取非法值），而且这样一来即使是搜索数组的某一段，也可以很方便根据这个条件地找到初始位置。 

如果假设L最终会停在第一个大于等于x的位置，R停在L的位置，那么循环不变式就是“L的左边恒小于x，R以及R的右边恒大于等于x”，这样的话，循环条件就是L等于R的时候退出；转移的时候R=mid；初始时，一般取R=n（如果保证x在数组里，也可以取n-1）。 

其他的情况也类似，比较直观的推导方法就是在要找的位置的分界处（比如在第一个大于等于x的位置后面）画一条线，然后假定L和R最终会停在这条线的左边还是右边，接着倒推各种条件即可。

```
# 在一个有序数组中，找小于等于某个数最右侧的位置
要求arr 是非递减的， 返回最小满足arr[i]  >= num 的 i
如果不存在，返回 len
## 左闭右闭

```c++
int binaryLeft(int *arr, int num, int len) {  
    if (arr == nullptr||len<=0) {    
        return -1;    
    }    
    int l = 0;    
    int r =len-1;  // 区间 [left, ritht]    int mid = 0;    
    while (l <= r){  // 区间不为空 当 l > r 区间就会变成空的，退出循环  
        mid =l+(r-l)/2;    
        if(arr[mid] < num){  
            l = mid+1;//需要看的区间变成[mid+1, right]  
        }    
        else{  
            r = mid-1; //需要看的区间变成[left, mid-1]}    
		}    
    }  
    return l;    
}
```

## 左闭右开

```c++
int binaryLeft(int *arr, int num, int len){  
    if (arr == nullptr||len<=0) {  
        return -1;  
    }  
    int l = 0;  
    int r =len ;  // 区间 [left, ritht)
    int mid = 0;  
    while (l < r){  // 区间不为空，当 l = r 区间就会变成空的，退出循环
        mid =l+(r-l)/2;  
        //确定mid的位置
        if(arr[mid] < num){ 
	        l = mid+1;//需要看的区间变成[mid+1, right） 
        }  
        else{ 
	        r = mid; //需要看的区间变成[left, mid）
        }  
    }  
    return l;  
}
```

## 左开右开
```c++
int binaryLeft(int *arr, int num, int len){  
    if (arr == nullptr||len<=0) {  
        return -1;  
    }  
    int l = -1;  
    int r =len ;  // 区间 （left, ritht)
    int mid = 0;  
    while (l + 1 < r){  // 区间不为空，当 l+1 = r 区间就会变成空的，退出循环
        mid =l+(r-l)/2;  
        if(arr[mid] < num){ 
	        l = mid;//需要看的区间变成[mid+1, right） 
	    }  
        else{ 
	        r = mid; //需要看的区间变成[left, mid）
        }  
    }  
    return l;  
}
```

## 0x3f

```c++
// lower_bound 返回最小的满足 nums[i] >= target 的下标 i
    // 如果数组为空，或者所有数都 < target，则返回 nums.size()
    // 要求 nums 是非递减的，即 nums[i] <= nums[i + 1]
    int lower_bound(vector<int>& nums, int target) {
        int left = 0, right = (int) nums.size() - 1; // 闭区间 [left, right]
        while (left <= right) { // 区间不为空
            // 循环不变量：
            // nums[left-1] < target
            // nums[right+1] >= target
            int mid = left + (right - left) / 2;
            if (nums[mid] >= target) {
                right = mid - 1; // 范围缩小到 [left, mid-1]
            } else {
                left = mid + 1; // 范围缩小到 [mid+1, right]
            }
        }
        // 循环结束后 left = right+1
        // 此时 nums[left-1] < target 而 nums[left] = nums[right+1] >= target
        // 所以 left 就是第一个 >= target 的元素下标
        return left;
    }

```



[[在排序数组中查找元素的第一个和最后一个位置]] 
我的和0x3f都差不多，就不写了

```c++
int binaryLeft(vector<int>& arr, int num ) {  
    int len = arr.size() ;  
    int l = 0;  
    int r =len-1;  // 区间 [left, ritht]    int mid = 0;  
    while (l <= r){  // 区间不为空 当 l > r 区间就会变成空的，退出循环  
        mid =l+(r-l)/2;  
        if(arr[mid] < num){  
            l = mid+1;//需要看的区间变成[mid+1, right]  
        }  
        else{  
            r = mid-1; //需要看的区间变成[left, mid-1]}  
        }  
    }  
    return l;  
}  
vector<int> searchRange(vector<int>& nums, int target) {  
    int left = binaryLeft(nums,target);  
    if(left == nums.size()|| nums[left]!=target){return {-1,-1};}  
    int right = binaryLeft(nums,target+1)-1;  
    return {left,right};  
}
```

# [2529. 正整数和负整数的最大计数](https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/)

找到不变量，确定left和right最后会停在什么地方那个，那么题目就很好解了
```c++
int maximumCount(vector<int>& nums) {  
    int n = nums.size();  
    int left = 0, right = n-1;  
    while(left <= right) {  
        int mid = left + (right - left) / 2;  
        // 不变量就是，right右边一定都是>0的， left的左边一定都是<=0的  
        if(nums[mid] > 0) {  
            right = mid-1;  
        }else {  
            left = mid+1;  
        }  
    }  
    --left;  
    while(left >= 0 && nums[left] == 0){--left;}  
    return max(left+1,n-right-1);  
}
```

0x3f

由于数组是有序的，我们可以二分找到第一个 ≥0 的数的下标 i，那么下标在 [0,i−1] 中的数都小于 0，这恰好有 i 个。

同样地，二分找到第一个 >0 的数的下标 j，那么下标在 [j,n−1] 中的数都大于 0，这有 n−j 个。

```c++
class Solution {
public:
    int maximumCount(vector<int> &nums) {
        int neg = ranges::lower_bound(nums, 0) - nums.begin();
        int pos = nums.end() - ranges::upper_bound(nums, 0);
        return max(neg, pos);
    }
};
```


# [2300. 咒语和药水的成功对数](https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/)

不难，但需要考虑两个主要问的问题

1. 用long long 保存数据
2.不能使用乘法算posion，时间复杂度会爆炸
对于正整数，  
$$
[ xy \geq success ] 等价于  
[ y \geq \left\lceil \frac{success}{x} \right\rceil ]。
$$
为了方便二分，可以利用如下公式：  
$$[
\left\lceil \frac{a}{b} \right\rceil = \frac{a + b - 1}{b} = \frac{a - 1}{b} + 1
]$$

讨论 \(a\) 被 \(b\) 整除，和不被 \(b\) 整除两种情况，可以证明上述公式的正确性。

根据上述式，我们有  
$$[
y \geq \left\lceil \frac{success}{x} \right\rceil = \frac{success - 1}{x} + 1
]$$

这等价于  
$$[
y > \frac{success - 1}{x}
]$$

对 `potions` 排序后，就可以二分查找了：设 \(x = spells[i]\)，\(j\) 是最小的满足  
$$[
potions[j] > \frac{success - 1}{x}
]$$
的下标，由于数组已经排序，那么下标大于 \(j\) 的也同样满足该式，这一共有 (m - j) 个，其中 (m) 是 `potions` 的长度。

**为什么不等式一定要这样变形？**  
好处是每次二分只需要做一次除法，避免多次在二分循环内做乘法，效率更高。另外的好处是部分语言可以直接调用库函数二分。
```c++
class Solution {
public:
    vector<int> successfulPairs(vector<int> &spells, vector<int> &potions, long long success) {
        ranges::sort(potions);
        for (int &x : spells) {
            long long target = (success - 1) / x;
            if (target < potions.back()) {
                // 这样写每次二分就只用 int 比较，避免把 potions 中的元素转成 long long 比较
                x = potions.end() - ranges::upper_bound(potions, (int) target);
            } else {
                x = 0;
            }
        }
        return spells;
    }
};
```

# [2563. 统计公平数对的数目](https://leetcode.cn/problems/count-the-number-of-fair-pairs/)

首先还是
1. 确定不变量，确定左指针左边是什么，右指针右边是什么
2. 注意往函数传入迭代器，而不是复制，不会会是时间超时
3. 迭代器范围是i+1
```c++
int lower_bound(vector<int>::iterator begin, vector<int>::iterator end, int target) {  
    auto left = begin, right = end;  
    while (left < right) {  
        auto mid = left + (right - left) / 2;  
        if (*mid >= target) {  
            right = mid;  
        } else {  
            left = mid + 1;  
        }  
    }  
    return left - begin; // 返回相对位置  
}  
  
int upper_bound(vector<int>::iterator begin, vector<int>::iterator end, int target) {  
    auto left = begin, right = end;  
    while (left < right) {  
        auto mid = left + (right - left) / 2;  
        if (*mid > target) {  
            right = mid;  
        } else {  
            left = mid + 1;  
        }  
    }  
    return left - begin; // 返回相对位置  
}  
  
long long countFairPairs(vector<int>& nums, int lower, int upper) {  
    sort(nums.begin(), nums.end());  
    long long result = 0;  
  
    for (int i = 0; i < nums.size() - 1; ++i) {  
        int lower1 = lower - nums[i];  
        int upper1 = upper - nums[i];  
        // 直接在原数组的后半部分使用迭代器传递范围  
        int left = lower_bound(nums.begin() + i + 1, nums.end(), lower1);  
        int right = upper_bound(nums.begin() + i + 1, nums.end(), upper1) - 1;  
  
        if (left <= right) {  
            result += right - left + 1;  
        }  
    }  
    return result;  
}
```

0x3f
他用的upper_bound和lower_bound
• upper_bound 和 lower_bound 是STL中的二分查找函数：
• upper_bound(first, last, value)：找到 **第一个大于**value**的位置**。
• lower_bound(first, last, value)：找到 **第一个不小于**value**的位置**。

```c++
class Solution {
public:
    long long countFairPairs(vector<int> &nums, int lower, int upper) {
        ranges::sort(nums);
        long long ans = 0;
        for (int j = 0; j < nums.size(); j++) {
            auto r = upper_bound(nums.begin(), nums.begin() + j, upper - nums[j]); // <= upper-nums[j] 的 nums[i] 的个数
            auto l = lower_bound(nums.begin(), nums.begin() + j, lower - nums[j]); // < lower-nums[j] 的 nums[i] 的个数
            ans += r - l;
        }
        return ans;
    }
};
```

# [2080. 区间内查询数字的频率](https://leetcode.cn/problems/range-frequency-queries/)


还是存在复制数组，然后超时的问题要注意，所以采用0x3f的做法


对于每个数，统计其在 arr 中的下标。例如 arr=[1,2,1,1,2,2]，其中数字 2 的下标为 [1,4,5]。

知道了下标，那么对于 query 来说，问题就变成了：

下标列表中，满足 left≤i≤right 的下标 i 的个数。
例如 query(3,5,2)，那么 2 的下标列表 [1,4,5] 中的下标 4 和 5 就是满足要求的，返回 2。

把下标列表记作数组 a，由于 a 是有序数组，我们可以用二分查找快速求出：

a 中的第一个 ≥left 的数的下标，设其为 p。如果不存在则 p 等于 a 的长度。
a 中的第一个 >right 的数的下标，设其为 q。如果不存在则 p 等于 a 的长度。
那么 a 中的下标在 \[p,q) 内的数都是满足要求的，这有 q−p 个。如果 a 中不存在这样的数，那么 q−p=0，也符合要求。

==利用下标天然有序==
==直接遍历的时间复杂度都是O(n)，先排序再找，明显不合理，要先观察暴力解法的时间复杂度，再思考优化算法，这样才可以有的放矢==
```c++
class RangeFreqQuery {
    unordered_map<int, vector<int>> pos;

public:
    RangeFreqQuery(vector<int>& arr) {
        for (int i = 0; i < arr.size(); i++) {
            pos[arr[i]].push_back(i);
        }
    }

    int query(int left, int right, int value) {
        // 不推荐写 a = pos[value]，如果 value 不在 pos 中会插入 value
        auto it = pos.find(value);
        if (it == pos.end()) {
            return 0;
        }
        auto& a = it->second; //注意用&，这样就不会进行拷贝，出现O(n)的时间复杂度
        return ranges::upper_bound(a, right) - ranges::lower_bound(a, left);
    }
};
```



# [275. H 指数 II](https://leetcode.cn/problems/h-index-ii/)
没什么难度，确定好h是怎么计算的，找不变量，就好了，详细解释请看0x3f的注释
```c++
int hIndex(vector<int>& citations) {  
    int n = citations.size();  
    int left =0, right = n-1;  
      
    while (left <= right) {  
        int mid = left + (right - left) / 2;  
        // right 右边的都是h, left左边的都不是h  
        if (citations[mid] >= n - mid) {  
            right = mid - 1;  
        }else {  
            left = mid + 1;  
        }  
    }  
    return n-left;  
}
```

0x3f的详细标注版
```c++
class Solution {
public:
    int hIndex(vector<int> &citations) {
        // 在区间 [left, right] 内询问
        int n = citations.size();
        int left = 1;
        int right = n;
        while (left <= right) { // 区间不为空
            // 循环不变量：
            // left-1 的回答一定为「是」
            // right+1 的回答一定为「否」
            int mid = (left + right) / 2; // left+(right-left)/2
            // 引用次数最多的 mid 篇论文，引用次数均 >= mid
            if (citations[n - mid] >= mid) {
                left = mid + 1; // 询问范围缩小到 [mid+1, right]
            } else {
                right = mid - 1; // 询问范围缩小到 [left, mid-1]
            }
        }
        // 循环结束后 right 等于 left-1，回答一定为「是」
        // 根据循环不变量，right 现在是最大的回答为「是」的数
        return right;
    }
};
```

# 
# 左笔记
https://blog.csdn.net/groovy2007/article/details/78309120
[[入门笔记#二分法]]
[[二分法]]
[[二分法模板]]
[[不是必须有序才能二分]]
