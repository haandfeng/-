#0x3f #链表 

# 反转操作

记住一个性质：

反转结束后，从原来的链表上看：
pre指向反转这一段的原本的末尾，反转后的头
cur指向反转这一段段后续的下一个节点
P0.next 会指向反转后的最后一个节个
## [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

[[反转链表]]
[[单链表和双链表如何反转]]
注意性质，返回的值，基础题，今天写文书，所以写了一个基础题
三个变量反转链表
```c++
class Solution {  
public:  
    ListNode* reverseList(ListNode* head) {  
        if (head == nullptr) return nullptr;  
        if (head->next == nullptr) return head;  
        ListNode* cur = head, *prev = nullptr, *next = nullptr;  
        while (cur) {  
            next = cur->next;  
            cur->next = prev;  
            prev = cur;  
            cur = next;  
        }  
        return prev;  
    }  
};
```
## [92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)

根据性质，头指向pre，反转后的尾指向cur

注意反转开头，开头没有开头->使用哨兵节点，这样子就可以翻转的是避免头的问题

我写得很丑陋，思路没啥问题，要用P0作为哨兵，这样才有开头

```c++
ListNode* reverseBetween(ListNode* head, int left, int right) {  
    ListNode* P0= new ListNode(0, head);  
    ListNode *prev = nullptr, *cur = P0, *next = nullptr;  
    for (int i = 0; i < left; i++) {  
        prev = cur;  
        cur = cur->next;  
    }  
    ListNode* head0 = prev;  
    ListNode* head1 = cur;  
  
    while (left <= right) {  
        next = cur->next;  
        cur->next = prev;  
        prev = cur;  
        cur = next;  
        ++left;  
    }  
    head1->next = cur;  
    head0->next= prev;  
    head = P0->next;  
    delete P0;  
    return head;  
}
```

0x3f的
P0应该表示翻转的前一个节点
![[Pasted image 20241230202917.png]]
```c++
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        ListNode dummy(0, head);
        ListNode* p0 = &dummy;
        for (int i = 0; i < left - 1; i++) {
            p0 = p0->next;
        }

        ListNode* pre = nullptr;
        ListNode* cur = p0->next;
        for (int i = 0; i < right - left + 1; i++) {
            ListNode* nxt = cur->next;
            cur->next = pre; // 每次循环只修改一个 next，方便大家理解
            pre = cur;
            cur = nxt;
        }

        // 见视频
        p0->next->next = cur;
        p0->next = pre;
        return dummy.next;
    }
};
```
## [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

[[K个节点的组内逆序调整]]
[[链表高频题和必备技巧#每k个节点一组翻转链表|每k个节点一组翻转链表]]

翻转之前要先判断节点个数，注意p0（哨兵）的修改

重要事件

反转结束后，从原来的链表上看：
pre指向反转这一段的原本的末尾，反转后的头
cur指向反转这一段段后续的下一个节点
P0.next 会指向反转后的最后一个节个
```c++
ListNode* reverseKGroup(ListNode* head, int k) {  
    int count = 0;  
    ListNode* cur = head;  
    while (cur!=nullptr) {  
        cur = cur->next;  
        ++count;  
    }  
    ListNode dummy(0,head);  
    ListNode* P0 = &dummy;  
    ListNode* pre = nullptr, *next = nullptr;  
    cur = head;  
    for (int i = 0; i+k <= count; i+=k) {  
        for (int j = i; j < i+k; j++) {  
            next = cur->next;  
            cur->next = pre;  
            pre = cur;  
            cur = next;  
        }  
        P0->next->next = cur;  
        ListNode* tmp = P0->next;;  
        P0->next = pre;  
        // pre可以不更新，因为第一个cur->next指向pre，但第一个的cur->next会重新更新（P0->next->next = cur ）
        pre = P0 = tmp;  
    }  
    return dummy.next;  
}
```


0x3f
```c++
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        // 统计节点个数
        int n = 0;
        for (ListNode* cur = head; cur; cur = cur->next) {
            n++;
        }

        ListNode dummy(0, head);
        ListNode* p0 = &dummy;
        ListNode* pre = nullptr;
        ListNode* cur = head;

        // k 个一组处理
        for (; n >= k; n -= k) {
            for (int i = 0; i < k; i++) { // 同 92 题
                ListNode* nxt = cur->next;
                cur->next = pre; // 每次循环只修改一个 next，方便大家理解
                pre = cur;
                cur = nxt;
            }

            // 见视频
            ListNode* nxt = p0->next;
            p0->next->next = cur;
            p0->next = pre;
            p0 = nxt;
        }
        return dummy.next;
    }
};
```

## [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

就是k变成了2，没有其他区别

```c++
ListNode* swapPairs(ListNode* head) {  
    ListNode dummy(0,head);  
    ListNode* P0 = &dummy;  
    ListNode* pre = nullptr;  
    ListNode* cur = head;  
    ListNode* nxt = nullptr;  
  
    while (cur != nullptr && cur->next != nullptr) {  
        for (int i = 0 ; i<2; i++) {  
            nxt = cur->next;  
            cur->next = pre;  
            nxt = cur;  
            cur = nxt;  
        }  
        P0->next->next = cur;  
        ListNode* tmp = P0->next;;  
        P0->next = pre;  
        P0 = tmp;  
    }  
    return dummy.next;  
}

```


0x3f的
建议看他的解释，感觉还是比较好理解的->
启示：
1. 一定要有一个dummy，这样就可以解决一个节点，0个节点的问题，
2. 看不懂画图就好了，看懂每一个节点要怎么移动


```c++
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode dummy(0, head); // 用哨兵节点简化代码逻辑
        ListNode* node0 = &dummy;
        ListNode* node1 = head;
        while (node1 && node1->next) { // 至少有两个节点
            ListNode* node2 = node1->next;
            ListNode* node3 = node2->next;

            node0->next = node2; // 0 -> 2
            node2->next = node1; // 2 -> 1
            node1->next = node3; // 1 -> 3

            node0 = node1; // 下一轮交换，0 是 1
            node1 = node3; // 下一轮交换，1 是 3
        }
        return dummy.next; // 返回新链表的头节点
    }
};
```

## [445. 两数相加 II](https://leetcode.cn/problems/add-two-numbers-ii/)
[[两数相加]] [[两个链表相加]] [[入门笔记#两个链表相加]]
先看两数相加（最新）or 两个链表想加，看看怎么实现两个链表相加
```c++
ListNode* addTwoNumbers2(ListNode* l1, ListNode* l2) {  
    ListNode dummy; // 哨兵节点  
    ListNode* cur = &dummy;  
    int carry = 0; // 进位  
    while (l1 || l2 || carry) { // 有一个不是空节点，或者还有进位，就继续迭代  
        if (l1) {  
            carry += l1->val; // 节点值和进位加在一起  
            l1 = l1->next; // 下一个节点  
        }  
        if (l2) {  
            carry += l2->val; // 节点值和进位加在一起  
            l2 = l2->next; // 下一个节点  
        }  
        cur = cur->next = new ListNode(carry % 10); // 每个节点保存一个数位  
        carry /= 10; // 新的进位  
    }  
    return dummy.next; // 哨兵节点的下一个节点就是头节点  
}  
ListNode* reverseList(ListNode* head) {  
    if (head == nullptr) return nullptr;  
    if (head->next == nullptr) return head;  
    ListNode* cur = head, *prev = nullptr, *next = nullptr;  
    while (cur) {  
        next = cur->next;  
        cur->next = prev;  
        prev = cur;  
        cur = next;  
    }  
    return prev;  
}  
ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {  
    l1 = reverseList(l1);  
    l2 = reverseList(l2);  
    return reverseList(addTwoNumbers2(l1, l2));  
}
```


0x3f
迭代算法和我的一样，可以看看他的递归算法


## [2816. 翻倍以链表形式表示的数字](https://leetcode.cn/problems/double-a-number-represented-as-a-linked-list/)
和上一题一样的思路
```c++
ListNode* reverseList(ListNode* head) {  
    if (head == nullptr) return nullptr;  
    if (head->next == nullptr) return head;  
    ListNode* cur = head, *prev = nullptr, *next = nullptr;  
    while (cur) {  
        next = cur->next;  
        cur->next = prev;  
        prev = cur;  
        cur = next;  
    }  
    return prev;  
}
ListNode* doubleIt(ListNode* head) {  
    head = reverseList(head);  
    ListNode dummy; // 哨兵节点  
    ListNode* cur = &dummy;  
    int carry = 0; // 进位  
    while (head || carry) {  
        if (head) {  
            carry = head->val*2 + carry;  
            head = head->next;  
        }  
        cur = cur->next = new ListNode(carry % 10);  
        carry /= 10;  
    }  
    return reverseList(dummy.next);  
}
```

# 快慢指针
## [876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/)
[[利用快慢指针返回链表的中点]]
可以通过数学归纳法，证明一定是对的



## [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)
[[环形链表]]
[[判断链表是否有环]]

## [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)
[[环形链表 II]]
[[找到链表第一个入环节点]]  
[[链表高频题和必备技巧#返回链表的第一个入环节点]]
[[两个可能有环的单链表相交的第一个节点]] 
[[两个可能有环的单链表相交的第一个节点-难点释疑]]
结论，当快慢指针相遇的时候，慢指针还没有走完一圈
严谨的相遇一定是入口，可以看视频

## [143. 重排链表](https://leetcode.cn/problems/reorder-list/)
[[重排链表]]
先找中点，然后把链表的中间节点开始的数反转
然后合并


## [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)


[[回文链表]]  [[判断链表是否为回文结构]] [[链表高频题和必备技巧#判断链表是否是回文结构]]



# 左链接
[[基础知识点#链表基础操作]]
[[入门笔记#链表]]
[[链表相关问题]]
[[链表高频题和必备技巧]]
[[02 链表结构、栈、队列、递归行为、哈希表和有序表]]
 [[03 链表结构、栈、队列、递归行为、哈希表和有序表]]
 [[04 单链表跟双链表]]   
[[06 链表相关面试题]]
[[09 链表问题在面试中的考察重点]]
[[双指针-首尾指针法]]