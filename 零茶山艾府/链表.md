#0x3f #链表 

# 反转操作

记住一个性质：

反转结束后，从原来的链表上看：
pre指向反转这一段的原本的末尾，反转后的头
cur指向反转这一段段后续的下一个节点
P0.next 会指向反转后的最后一个节个
## [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

[[反转链表]]
[[单链表和双链表如何反转]]
注意性质，返回的值，基础题，今天写文书，所以写了一个基础题
三个变量反转链表
```c++
class Solution {  
public:  
    ListNode* reverseList(ListNode* head) {  
        if (head == nullptr) return nullptr;  
        if (head->next == nullptr) return head;  
        ListNode* cur = head, *prev = nullptr, *next = nullptr;  
        while (cur) {  
            next = cur->next;  
            cur->next = prev;  
            prev = cur;  
            cur = next;  
        }  
        return prev;  
    }  
};
```
## [92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)

根据性质，头指向pre，反转后的尾指向cur

注意反转开头，开头没有开头->使用哨兵节点，这样子就可以翻转的是避免头的问题

我写得很丑陋，思路没啥问题，要用P0作为哨兵，这样才有开头

```c++
ListNode* reverseBetween(ListNode* head, int left, int right) {  
    ListNode* P0= new ListNode(0, head);  
    ListNode *prev = nullptr, *cur = P0, *next = nullptr;  
    for (int i = 0; i < left; i++) {  
        prev = cur;  
        cur = cur->next;  
    }  
    ListNode* head0 = prev;  
    ListNode* head1 = cur;  
  
    while (left <= right) {  
        next = cur->next;  
        cur->next = prev;  
        prev = cur;  
        cur = next;  
        ++left;  
    }  
    head1->next = cur;  
    head0->next= prev;  
    head = P0->next;  
    delete P0;  
    return head;  
}
```

0x3f的
P0应该表示翻转的前一个节点
![[Pasted image 20241230202917.png]]
```c++
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        ListNode dummy(0, head);
        ListNode* p0 = &dummy;
        for (int i = 0; i < left - 1; i++) {
            p0 = p0->next;
        }

        ListNode* pre = nullptr;
        ListNode* cur = p0->next;
        for (int i = 0; i < right - left + 1; i++) {
            ListNode* nxt = cur->next;
            cur->next = pre; // 每次循环只修改一个 next，方便大家理解
            pre = cur;
            cur = nxt;
        }

        // 见视频
        p0->next->next = cur;
        p0->next = pre;
        return dummy.next;
    }
};
```
## [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

[[K个节点的组内逆序调整]]
[[链表高频题和必备技巧#每k个节点一组翻转链表|每k个节点一组翻转链表]]

翻转之前要先判断节点个数，注意p0（哨兵）的修改

重要事件

反转结束后，从原来的链表上看：
pre指向反转这一段的原本的末尾，反转后的头
cur指向反转这一段段后续的下一个节点
P0.next 会指向反转后的最后一个节个
```c++
ListNode* reverseKGroup(ListNode* head, int k) {  
    int count = 0;  
    ListNode* cur = head;  
    while (cur!=nullptr) {  
        cur = cur->next;  
        ++count;  
    }  
    ListNode dummy(0,head);  
    ListNode* P0 = &dummy;  
    ListNode* pre = nullptr, *next = nullptr;  
    cur = head;  
    for (int i = 0; i+k <= count; i+=k) {  
        for (int j = i; j < i+k; j++) {  
            next = cur->next;  
            cur->next = pre;  
            pre = cur;  
            cur = next;  
        }  
        P0->next->next = cur;  
        ListNode* tmp = P0->next;;  
        P0->next = pre;  
        // pre可以不更新，因为第一个cur->next指向pre，但第一个的cur->next会重新更新（P0->next->next = cur ）
        pre = P0 = tmp;  
    }  
    return dummy.next;  
}
```


0x3f
```c++
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        // 统计节点个数
        int n = 0;
        for (ListNode* cur = head; cur; cur = cur->next) {
            n++;
        }

        ListNode dummy(0, head);
        ListNode* p0 = &dummy;
        ListNode* pre = nullptr;
        ListNode* cur = head;

        // k 个一组处理
        for (; n >= k; n -= k) {
            for (int i = 0; i < k; i++) { // 同 92 题
                ListNode* nxt = cur->next;
                cur->next = pre; // 每次循环只修改一个 next，方便大家理解
                pre = cur;
                cur = nxt;
            }

            // 见视频
            ListNode* nxt = p0->next;
            p0->next->next = cur;
            p0->next = pre;
            p0 = nxt;
        }
        return dummy.next;
    }
};
```
# 左链接
[[基础知识点#链表基础操作]]
[[入门笔记#链表]]
[[链表相关问题]]
[[链表高频题和必备技巧]]
[[02 链表结构、栈、队列、递归行为、哈希表和有序表]]
 [[03 链表结构、栈、队列、递归行为、哈希表和有序表]]
 [[04 单链表跟双链表]]   
[[06 链表相关面试题]]
[[09 链表问题在面试中的考察重点]]